<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pgmpy.models.SEM &#8212; pgmpy 0.1.23 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=7b53859b" />
    <script src="../../../_static/documentation_options.js?v=20522496"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pgmpy.models.SEM</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms.dag</span> <span class="kn">import</span> <span class="n">descendants</span>

<span class="kn">from</span> <span class="nn">pgmpy.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">pgmpy.global_vars</span> <span class="kn">import</span> <span class="n">logger</span>


<div class="viewcode-block" id="SEMGraph">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph">[docs]</a>
<span class="k">class</span> <span class="nc">SEMGraph</span><span class="p">(</span><span class="n">DAG</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for graphical representation of Structural Equation Models(SEMs).</span>

<span class="sd">    All variables are by default assumed to have an associated error latent variable, therefore</span>
<span class="sd">    doesn&#39;t need to be specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ebunch: list/array-like</span>
<span class="sd">        List of edges in form of tuples. Each tuple can be of two possible shape:</span>
<span class="sd">            1. (u, v): This would add an edge from u to v without setting any parameter</span>
<span class="sd">                       for the edge.</span>
<span class="sd">            2. (u, v, parameter): This would add an edge from u to v and set the edge&#39;s</span>
<span class="sd">                        parameter to `parameter`.</span>

<span class="sd">    latents: list/array-like</span>
<span class="sd">        List of nodes which are latent. All other variables are considered observed.</span>

<span class="sd">    err_corr: list/array-like</span>
<span class="sd">        List of tuples representing edges between error terms. It can be of the following forms:</span>
<span class="sd">            1. (u, v): Add correlation between error terms of `u` and `v`. Doesn&#39;t set any variance or</span>
<span class="sd">                       covariance values.</span>
<span class="sd">            2. (u, v, covar): Adds correlation between the error terms of `u` and `v` and sets the</span>
<span class="sd">                              parameter to `covar`.</span>

<span class="sd">    err_var: dict (variable: variance)</span>
<span class="sd">        Sets variance for the error terms in the model.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Defining a model (Union sentiment model[1]) without setting any paramaters.</span>
<span class="sd">    &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">    &gt;&gt;&gt; sem = SEMGraph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">    ...                        (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">    ...                        (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">    ...                latents=[],</span>
<span class="sd">    ...                err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">    ...                err_var={})</span>

<span class="sd">    Defining a model (Education [2]) with all the parameters set. For not setting any</span>
<span class="sd">    parameter `np.nan` can be explicitly passed.</span>
<span class="sd">    &gt;&gt;&gt; sem_edu = SEMGraph(ebunch=[(&#39;intelligence&#39;, &#39;academic&#39;, 0.8), (&#39;intelligence&#39;, &#39;scale_1&#39;, 0.7),</span>
<span class="sd">    ...                            (&#39;intelligence&#39;, &#39;scale_2&#39;, 0.64), (&#39;intelligence&#39;, &#39;scale_3&#39;, 0.73),</span>
<span class="sd">    ...                            (&#39;intelligence&#39;, &#39;scale_4&#39;, 0.82), (&#39;academic&#39;, &#39;SAT_score&#39;, 0.98),</span>
<span class="sd">    ...                            (&#39;academic&#39;, &#39;High_school_gpa&#39;, 0.75), (&#39;academic&#39;, &#39;ACT_score&#39;, 0.87)],</span>
<span class="sd">    ...                    latents=[&#39;intelligence&#39;, &#39;academic&#39;],</span>
<span class="sd">    ...                    err_corr=[],</span>
<span class="sd">    ...                    err_var={&#39;intelligence&#39;: 1})</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] McDonald, A, J., &amp; Clelland, D. A. (1984). Textile Workers and Union Sentiment.</span>
<span class="sd">        Social Forces, 63(2), 502â€“521</span>
<span class="sd">    [2] https://en.wikipedia.org/wiki/Structural_equation_modeling#/</span>
<span class="sd">        media/File:Example_Structural_equation_model.svg</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    latents: list</span>
<span class="sd">        List of all the latent variables in the model except the error terms.</span>

<span class="sd">    observed: list</span>
<span class="sd">        List of all the observed variables in the model.</span>

<span class="sd">    graph: nx.DirectedGraph</span>
<span class="sd">        The graphical structure of the latent and observed variables except the error terms.</span>
<span class="sd">        The parameters are stored in the `weight` attribute of each edge.</span>

<span class="sd">    err_graph: nx.Graph</span>
<span class="sd">        An undirected graph representing the relations between the error terms of the model.</span>
<span class="sd">        The node of the graph has the same name as the variable but represents the error terms.</span>
<span class="sd">        The variance is stored in the `weight` attribute of the node and the covariance are stored</span>
<span class="sd">        in the `weight` attribute of the edge.</span>

<span class="sd">    full_graph_struct: nx.DiGraph</span>
<span class="sd">        Represents the full graph structure. The names of error terms start with `.` and</span>
<span class="sd">        new nodes are added for each correlation which starts with `..`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{}):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SEMGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Construct the graph and set the parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ebunch</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected tuple length: 2 or 3. Got </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> of len </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="c1"># Construct the error graph and set the parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">err_corr</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected tuple length: 2 or 3. Got </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> of len </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Set the error variances</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">err_var</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">err_var</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_full_graph_struct</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_full_graph_struct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a directed graph by joining `self.graph` and `self.err_graph`.</span>
<span class="sd">        Adds new nodes to replace undirected edges (u &lt;--&gt; v) with two directed</span>
<span class="sd">        edges (u &lt;-- ..uv) and (..uv --&gt; v).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.DiGraph: A full directed graph strucuture with error nodes starting</span>
<span class="sd">                    with `.` and bidirected edges replaced with common cause</span>
<span class="sd">                    nodes starting with `..`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; sem = SEMGraph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                        (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                        (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                latents=[],</span>
<span class="sd">        ...                err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; sem._get_full_graph_struct()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">mapping_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
        <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">cov_node</span> <span class="o">=</span> <span class="s2">&quot;..&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]))</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">cov_node</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">u</span><span class="p">),</span> <span class="p">(</span><span class="n">cov_node</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">full_graph</span>

<div class="viewcode-block" id="SEMGraph.get_scaling_indicators">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_scaling_indicators">[docs]</a>
    <span class="k">def</span> <span class="nf">get_scaling_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a scaling indicator for each of the latent variables in the model.</span>
<span class="sd">        The scaling indicator is chosen randomly among the observed measurement</span>
<span class="sd">        variables of the latent variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;xi1&#39;, &#39;eta1&#39;), (&#39;xi1&#39;, &#39;x1&#39;), (&#39;xi1&#39;, &#39;x2&#39;),</span>
<span class="sd">        ...                          (&#39;eta1&#39;, &#39;y1&#39;), (&#39;eta1&#39;, &#39;y2&#39;)],</span>
<span class="sd">        ...                  latents=[&#39;xi1&#39;, &#39;eta1&#39;])</span>
<span class="sd">        &gt;&gt;&gt; model.get_scaling_indicators()</span>
<span class="sd">        {&#39;xi1&#39;: &#39;x1&#39;, &#39;eta1&#39;: &#39;y1&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict: Returns a dict with latent variables as the key and their value being the</span>
<span class="sd">                scaling indicator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">:</span>
                    <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">scaling_indicators</span></div>


<div class="viewcode-block" id="SEMGraph.active_trail_nodes">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.active_trail_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">active_trail_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="p">[],</span> <span class="n">avoid_nodes</span><span class="o">=</span><span class="p">[],</span> <span class="n">struct</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the observed variables which are d-connected to `variables` in the `graph_struct`</span>
<span class="sd">        when `observed` variables are observed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            Observed variables whose d-connected variables are to be found.</span>

<span class="sd">        observed : list/array-like</span>
<span class="sd">            If given the active trails would be computed assuming these nodes to be observed.</span>

<span class="sd">        avoid_nodes: list/array-like</span>
<span class="sd">            If specificed, the algorithm doesn&#39;t account for paths that have influence flowing</span>
<span class="sd">            through the avoid node.</span>

<span class="sd">        struct: str or nx.DiGraph instance</span>
<span class="sd">            If &quot;full&quot;, considers correlation between error terms for computing d-connection.</span>
<span class="sd">            If &quot;non_error&quot;, doesn&#39;t condised error correlations for computing d-connection.</span>
<span class="sd">            If instance of nx.DiGraph, finds d-connected variables on the given graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;laboract&#39;),</span>
<span class="sd">        ...                          (&#39;age&#39;, &#39;deferenc&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;),</span>
<span class="sd">        ...                          (&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.active_trail_nodes(&#39;age&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict: {str: list}</span>
<span class="sd">            Returns a dict with `variables` as the key and a list of d-connected variables as the</span>
<span class="sd">            value.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Details of the algorithm can be found in &#39;Probabilistic Graphical Model</span>
<span class="sd">        Principles and Techniques&#39; - Koller and Friedman</span>
<span class="sd">        Page 75 Algorithm 3.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">struct</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span>
        <span class="k">elif</span> <span class="n">struct</span> <span class="o">==</span> <span class="s2">&quot;non_error&quot;</span><span class="p">:</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="n">struct</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected struct to be str or nx.DiGraph. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
            <span class="n">ancestors_list</span> <span class="o">=</span> <span class="n">ancestors_list</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph_struct</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Direction of flow of information</span>
        <span class="c1"># up -&gt;  from parent to child</span>
        <span class="c1"># down -&gt; from child to parent</span>

        <span class="n">active_trails</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]:</span>
            <span class="n">visit_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">traversed_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">active_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">visit_list</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">visit_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">avoid_nodes</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traversed_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">active_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">traversed_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span>
        <span class="k">return</span> <span class="n">active_trails</span></div>


    <span class="k">def</span> <span class="nf">_iv_transformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the graph structure of SEM so that the d-separation criterion is</span>
<span class="sd">        applicable for finding IVs. The method transforms the graph for finding MIIV</span>
<span class="sd">        for the estimation of X \rightarrow Y given the scaling indicator for all the</span>
<span class="sd">        parent latent variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The explantory variable.</span>

<span class="sd">        Y: node</span>
<span class="sd">            The dependent variable.</span>

<span class="sd">        scaling_indicators: dict</span>
<span class="sd">            Scaling indicator for each latent variable in the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.DiGraph: The transformed full graph structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;xi1&#39;, &#39;eta1&#39;), (&#39;xi1&#39;, &#39;x1&#39;), (&#39;xi1&#39;, &#39;x2&#39;),</span>
<span class="sd">        ...                          (&#39;eta1&#39;, &#39;y1&#39;), (&#39;eta1&#39;, &#39;y2&#39;)],</span>
<span class="sd">        ...                  latents=[&#39;xi1&#39;, &#39;eta1&#39;])</span>
<span class="sd">        &gt;&gt;&gt; model._iv_transformations(&#39;xi1&#39;, &#39;eta1&#39;,</span>
<span class="sd">        ...                           scaling_indicators={&#39;xi1&#39;: &#39;x1&#39;, &#39;eta1&#39;: &#39;y1&#39;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">full_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The edge from </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> doesn&#39;t exist in the graph&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_graph</span><span class="p">,</span> <span class="n">Y</span>

        <span class="k">elif</span> <span class="n">Y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">Y</span><span class="p">])</span>
            <span class="n">dependent_var</span> <span class="o">=</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dependent_var</span> <span class="o">=</span> <span class="n">Y</span>

        <span class="k">for</span> <span class="n">parent_y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="c1"># Remove edge even when the parent is observed ????</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent_y</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
                <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">parent_y</span><span class="p">],</span> <span class="n">dependent_var</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">full_graph</span><span class="p">,</span> <span class="n">dependent_var</span>

<div class="viewcode-block" id="SEMGraph.get_ivs">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_ivs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ivs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Instrumental variables(IVs) for the relation X -&gt; Y</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The variable name (observed or latent)</span>

<span class="sd">        Y: node</span>
<span class="sd">            The variable name (observed or latent)</span>

<span class="sd">        scaling_indicators: dict (optional)</span>
<span class="sd">            A dict representing which observed variable to use as scaling indicator for</span>
<span class="sd">            the latent variables.</span>
<span class="sd">            If not given the method automatically selects one of the measurement variables</span>
<span class="sd">            at random as the scaling indicator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set: {str}</span>
<span class="sd">            The set of Instrumental Variables for X -&gt; Y.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;I&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;X&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.get_ivs(&#39;X&#39;, &#39;Y&#39;)</span>
<span class="sd">        {&#39;I&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaling_indicators</span><span class="p">:</span>
            <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaling_indicators</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">scaling_indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">Y</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> is the scaling indicator of </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">. Please specify `scaling_indicators`&quot;</span>
            <span class="p">)</span>

        <span class="n">transformed_graph</span><span class="p">,</span> <span class="n">dependent_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iv_transformations</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="n">scaling_indicators</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="n">explanatory_var</span> <span class="o">=</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">explanatory_var</span> <span class="o">=</span> <span class="n">X</span>

        <span class="n">d_connected_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
            <span class="p">[</span><span class="n">explanatory_var</span><span class="p">],</span> <span class="n">struct</span><span class="o">=</span><span class="n">transformed_graph</span>
        <span class="p">)[</span><span class="n">explanatory_var</span><span class="p">]</span>

        <span class="c1"># Condition on X to block any paths going through X.</span>
        <span class="n">d_connected_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
            <span class="p">[</span><span class="n">dependent_var</span><span class="p">],</span> <span class="n">avoid_nodes</span><span class="o">=</span><span class="p">[</span><span class="n">explanatory_var</span><span class="p">],</span> <span class="n">struct</span><span class="o">=</span><span class="n">transformed_graph</span>
        <span class="p">)[</span><span class="n">dependent_var</span><span class="p">]</span>

        <span class="c1"># Remove {X, Y} because they can&#39;t be IV for X -&gt; Y</span>
        <span class="k">return</span> <span class="n">d_connected_x</span> <span class="o">-</span> <span class="n">d_connected_y</span> <span class="o">-</span> <span class="p">{</span><span class="n">dependent_var</span><span class="p">,</span> <span class="n">explanatory_var</span><span class="p">}</span></div>


<div class="viewcode-block" id="SEMGraph.moralize">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.moralize">[docs]</a>
    <span class="k">def</span> <span class="nf">moralize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO: This needs to go to a parent class.</span>
<span class="sd">        Removes all the immoralities in the DirectedGraph and creates a moral</span>
<span class="sd">        graph (UndirectedGraph).</span>

<span class="sd">        A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge</span>
<span class="sd">        between X and Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        graph:</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>

        <span class="n">moral_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">moral_graph</span></div>


    <span class="k">def</span> <span class="nf">_nearest_separator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the set of the nearest separators for `Y` and `Z` in `G`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G: nx.DiGraph instance</span>
<span class="sd">            The graph in which to the find the nearest separation for `Y` and `Z`.</span>

<span class="sd">        Y: str</span>
<span class="sd">            The variable name for which the separators are needed.</span>

<span class="sd">        Z: str</span>
<span class="sd">            The other variable for which the separators are needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set or None: If there is a nearest separator returns the set of separators else returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ancestral_G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">})</span>
        <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Optimization: Remove all error nodes which don&#39;t have any correlation as it doesn&#39;t add any new path. If not removed it can create a lot of</span>
        <span class="c1"># extra paths resulting in a much higher runtime.</span>
        <span class="n">err_nodes_to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">ancestral_G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">err_nodes_to_remove</span><span class="p">])</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moralize</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">ancestral_G</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">Y</span><span class="p">])</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>

        <span class="c1"># Another optimization over the original algo. Rather than going through all the paths does</span>
        <span class="c1"># a DFS search to find a markov blanket of observed variables. This doesn&#39;t ensure minimal observed</span>
        <span class="c1"># set.</span>
        <span class="k">while</span> <span class="n">to_visit</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">Z</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">:</span>
                <span class="n">W</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_visit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="c1"># for path in nx.all_simple_paths(M, Y, Z):</span>
        <span class="c1">#     path_set = set(path)</span>
        <span class="c1">#     if (len(path) &gt;= 3) and not (W &amp; path_set):</span>
        <span class="c1">#         for index in range(1, len(path)-1):</span>
        <span class="c1">#             if path[index] in self.observed:</span>
        <span class="c1">#                 W.add(path[index])</span>
        <span class="c1">#                 break</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">struct</span><span class="o">=</span><span class="n">ancestral_G</span><span class="p">)[</span><span class="n">Z</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">W</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="SEMGraph.get_conditional_ivs">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_conditional_ivs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_conditional_ivs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the conditional IVs for the relation X -&gt; Y</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The observed variable&#39;s name</span>

<span class="sd">        Y: node</span>
<span class="sd">            The oberved variable&#39;s name</span>

<span class="sd">        scaling_indicators: dict (optional)</span>
<span class="sd">            A dict representing which observed variable to use as scaling indicator for</span>
<span class="sd">            the latent variables.</span>
<span class="sd">            If not provided, automatically finds scaling indicators by randomly selecting</span>
<span class="sd">            one of the measurement variables of each latent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set: Set of 2-tuples representing tuple[0] is an IV for X -&gt; Y given tuple[1].</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Van Der Zander, B., Textor, J., &amp; Liskiewicz, M. (2015, June). Efficiently finding</span>
<span class="sd">               conditional instruments for causal inference. In Twenty-Fourth International Joint</span>
<span class="sd">               Conference on Artificial Intelligence.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;I&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;), (&#39;W&#39;, &#39;I&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;W&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.get_ivs(&#39;X&#39;, &#39;Y&#39;)</span>
<span class="sd">        [(&#39;I&#39;, {&#39;W&#39;})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaling_indicators</span><span class="p">:</span>
            <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaling_indicators</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">scaling_indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">Y</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> is the scaling indicator of </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">. Please specify `scaling_indicators`&quot;</span>
            <span class="p">)</span>

        <span class="n">transformed_graph</span><span class="p">,</span> <span class="n">dependent_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iv_transformations</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="n">scaling_indicators</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">transformed_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">G_c</span> <span class="o">=</span> <span class="n">transformed_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_c</span> <span class="o">=</span> <span class="n">transformed_graph</span>

        <span class="n">instruments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="p">{</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">}:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nearest_separator</span><span class="p">(</span><span class="n">G_c</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
            <span class="c1"># Condition to check if W d-separates Y from Z</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">W</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">descendants</span><span class="p">(</span><span class="n">G_c</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">W</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Condition to check if X d-connected to I after conditioning on W.</span>
            <span class="k">elif</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">struct</span><span class="o">=</span><span class="n">G_c</span><span class="p">)[</span><span class="n">Z</span><span class="p">]:</span>
                <span class="n">instruments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="n">instruments</span></div>


<div class="viewcode-block" id="SEMGraph.to_lisrel">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.to_lisrel">[docs]</a>
    <span class="k">def</span> <span class="nf">to_lisrel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the model from a graphical representation to an equivalent algebraic</span>
<span class="sd">        representation. This converts the model into a Reticular Action Model (RAM) model</span>
<span class="sd">        representation which is implemented by `pgmpy.models.SEMAlg` class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SEMAlg instance: Instance of `SEMAlg` representing the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; sem = SEM.from_graph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                              (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                              (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                      latents=[],</span>
<span class="sd">        ...                      err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">        ...                      err_var={})</span>
<span class="sd">        &gt;&gt;&gt; sem.to_lisrel()</span>
<span class="sd">        # TODO: Complete this.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_standard_lisrel: Converts to the standard lisrel format and returns the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span>
        <span class="n">graph_adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">graph_fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">err_adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">err_adj</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Variance exists for each error term.</span>
        <span class="n">err_fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Add the variance of the error terms.</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">):</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
            <span class="n">err_fixed</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">else</span> <span class="n">weight</span>

        <span class="n">wedge_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">obs_var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="n">wedge_y</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">nodelist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obs_var</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="kn">from</span> <span class="nn">pgmpy.models</span> <span class="kn">import</span> <span class="n">SEMAlg</span>

        <span class="k">return</span> <span class="n">SEMAlg</span><span class="p">(</span>
            <span class="n">eta</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">graph_adj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">err_adj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">wedge_y</span><span class="o">=</span><span class="n">wedge_y</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">graph_fixed</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;zeta&quot;</span><span class="p">:</span> <span class="n">err_fixed</span><span class="o">.</span><span class="n">T</span><span class="p">},</span>
        <span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__standard_lisrel_masks</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">err_graph</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called by `get_fixed_masks` and `get_masks` methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight: None | &#39;weight&#39;</span>
<span class="sd">            If None: Returns a 1.0 for an edge in the graph else 0.0</span>
<span class="sd">            If &#39;weight&#39;: Returns the weight if a weight is assigned to an edge</span>
<span class="sd">                    else 0.0</span>

<span class="sd">        var: dict</span>
<span class="sd">            Dict with keys eta, xi, y, and x representing the variables in them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: Adjacency matrix of model&#39;s graph structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        B: Effect matrix of eta on eta</span>
<span class="sd">        \gamma: Effect matrix of xi on eta</span>
<span class="sd">        \wedge_y: Effect matrix of eta on y</span>
<span class="sd">        \wedge_x: Effect matrix of xi on x</span>
<span class="sd">        \phi: Covariance matrix of xi</span>
<span class="sd">        \psi: Covariance matrix of eta errors</span>
<span class="sd">        \theta_e: Covariance matrix of y errors</span>
<span class="sd">        \theta_del: Covariance matrix of x errors</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Arrange the adjacency matrix in order y, x, eta, xi and then slice masks from it.</span>
        <span class="c1">#       y(p)   x(q)   eta(m)  xi(n)</span>
        <span class="c1"># y</span>
        <span class="c1"># x</span>
        <span class="c1"># eta \wedge_y          B</span>
        <span class="c1"># xi         \wedge_x \Gamma</span>
        <span class="c1">#</span>
        <span class="c1"># But here we are slicing from the transpose of adjacency because we want incoming</span>
        <span class="c1"># edges instead of outgoing because parameters come before variables in equations.</span>
        <span class="c1">#</span>
        <span class="c1">#       y(p)   x(q)   eta(m)  xi(n)</span>
        <span class="c1"># y                  \wedge_y</span>
        <span class="c1"># x                          \wedge_x</span>
        <span class="c1"># eta                   B    \Gamma</span>
        <span class="c1"># xi</span>
        <span class="n">y_vars</span><span class="p">,</span> <span class="n">x_vars</span><span class="p">,</span> <span class="n">eta_vars</span><span class="p">,</span> <span class="n">xi_vars</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]</span>

        <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">eta_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi_vars</span><span class="p">))</span>

        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">y_vars</span> <span class="o">+</span> <span class="n">x_vars</span> <span class="o">+</span> <span class="n">eta_vars</span> <span class="o">+</span> <span class="n">xi_vars</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">B_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">gamma_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>
        <span class="n">wedge_y_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">wedge_x_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>

        <span class="n">err_nodelist</span> <span class="o">=</span> <span class="n">y_vars</span> <span class="o">+</span> <span class="n">x_vars</span> <span class="o">+</span> <span class="n">eta_vars</span> <span class="o">+</span> <span class="n">xi_vars</span>
        <span class="n">err_adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span>
            <span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">err_nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">err_adj_matrix</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="n">theta_e_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[:</span><span class="n">p</span><span class="p">,</span> <span class="p">:</span><span class="n">p</span><span class="p">]</span>
        <span class="n">theta_del_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">]</span>
        <span class="n">psi_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">phi_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">B_mask</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma_mask</span><span class="p">,</span>
            <span class="s2">&quot;wedge_y&quot;</span><span class="p">:</span> <span class="n">wedge_y_mask</span><span class="p">,</span>
            <span class="s2">&quot;wedge_x&quot;</span><span class="p">:</span> <span class="n">wedge_x_mask</span><span class="p">,</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi_mask</span><span class="p">,</span>
            <span class="s2">&quot;theta_e&quot;</span><span class="p">:</span> <span class="n">theta_e_mask</span><span class="p">,</span>
            <span class="s2">&quot;theta_del&quot;</span><span class="p">:</span> <span class="n">theta_del_mask</span><span class="p">,</span>
            <span class="s2">&quot;psi&quot;</span><span class="p">:</span> <span class="n">psi_mask</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="SEMGraph.to_standard_lisrel">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.to_standard_lisrel">[docs]</a>
    <span class="k">def</span> <span class="nf">to_standard_lisrel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the model to the standard LISREL representation of latent and measurement</span>
<span class="sd">        equations. The standard LISREL representation is given as:</span>

<span class="sd">        ..math::</span>
<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\Gamma \xi} + \mathbf{\zeta} \\</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{x} = \mathbf{\wedge_x \xi} + \mathbf{\delta} \\</span>
<span class="sd">            \mathbf{\Theta_e} = COV(\mathbf{\epsilon}) \\</span>
<span class="sd">            \mathbf{\Theta_\delta} = COV(\mathbf{\delta}) \\</span>
<span class="sd">            \mathbf{\Psi} = COV(\mathbf{\eta}) \\</span>
<span class="sd">            \mathbf{\Phi} = COV(\mathbf{\xi}) \\</span>

<span class="sd">        Since the standard LISREL representation has restrictions on the types of model,</span>
<span class="sd">        this method adds extra latent variables with fixed loadings of `1` to make the model</span>
<span class="sd">        consistent with the restrictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var_names: dict (keys: eta, xi, y, x)</span>
<span class="sd">            Returns the variable names in :math:`\mathbf{\eta}`, :math:`\mathbf{\xi}`,</span>
<span class="sd">            :math:`\mathbf{y}`, :math:`\mathbf{x}`.</span>

<span class="sd">        params: dict (keys: B, gamma, wedge_y, wedge_x, theta_e, theta_del, phi, psi)</span>
<span class="sd">            Returns a boolean matrix for each of the parameters. A 1 in the matrix</span>
<span class="sd">            represents that there is an edge in the model, 0 represents there is no edge.</span>

<span class="sd">        fixed_values: dict (keys: B, gamma, wedge_y, wedge_x, theta_e, theta_del, phi, psi)</span>
<span class="sd">            Returns a matrix for each of the parameters. A value in the matrix represents the</span>
<span class="sd">            set value for the parameter in the model else it is 0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_lisrel: Converts the model to `pgmpy.models.SEMAlg` instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        TODO: Finish this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lisrel_err_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lisrel_latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lisrel_observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Add new latent nodes to convert it to LISREL format.</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">):</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">u</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">):</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">u</span>
        <span class="n">lisrel_latents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">lisrel_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Get values of eta, xi, y, x</span>
        <span class="n">latent_struct</span> <span class="o">=</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">lisrel_latents</span><span class="p">)</span>
        <span class="n">latent_indegree</span> <span class="o">=</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>

        <span class="n">eta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">latent_struct</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">latent_indegree</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">exo</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">exo</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lisrel_latents</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="n">eta</span><span class="p">:</span>
            <span class="n">y</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">endo</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lisrel_latents</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># If some node has edges from both eta and xi, replace it with another latent variable</span>
        <span class="c1"># otherwise it won&#39;t get included in any of the matrices.</span>
        <span class="c1"># TODO: Patchy work. Find a better solution.</span>
        <span class="n">common_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">common_elements</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">common_elements</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">var</span>
            <span class="n">lisrel_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">lisrel_graph</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_elements</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">common_elements</span><span class="p">)</span>

        <span class="n">var_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eta&quot;</span><span class="p">:</span> <span class="n">eta</span><span class="p">,</span> <span class="s2">&quot;xi&quot;</span><span class="p">:</span> <span class="n">xi</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
        <span class="n">edges_masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_lisrel_masks</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">lisrel_graph</span><span class="p">,</span> <span class="n">err_graph</span><span class="o">=</span><span class="n">lisrel_err_graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var_names</span>
        <span class="p">)</span>
        <span class="n">fixed_masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_lisrel_masks</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">lisrel_graph</span><span class="p">,</span>
            <span class="n">err_graph</span><span class="o">=</span><span class="n">lisrel_err_graph</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="n">var</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">edges_masks</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SEMAlg">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg">[docs]</a>
<span class="k">class</span> <span class="nc">SEMAlg</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for algebraic representation of Structural Equation Models(SEMs). The model is</span>
<span class="sd">    represented using the Reticular Action Model (RAM).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wedge_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes SEMAlg model. The model is represented using the Reticular Action Model(RAM)</span>
<span class="sd">        which is given as:</span>
<span class="sd">        ..math::</span>
<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\zeta}</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta}</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of all the observed and latent variables in the</span>
<span class="sd">        model, :math:`\mathbf{y}` are the set of observed variables, :math:`\mathbf{\zeta}` is</span>
<span class="sd">        the error terms for :math:`\mathbf{\eta}`, and \mathbf{\wedge_y} is a boolean array to</span>
<span class="sd">        select the observed variables from :math:`\mathbf{\eta}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        The following set of parameters are used to set the learnable parameters in the model.</span>
<span class="sd">        To specify the values of the parameter use the `fixed_values` parameter. Either `eta`,</span>
<span class="sd">        `B`, `zeta`, and `wedge_y`, or `fixed_values` need to be specified.</span>

<span class="sd">        eta: list/array-like</span>
<span class="sd">            The name of the variables in the model.</span>

<span class="sd">        B: 2-D array (boolean)</span>
<span class="sd">            The learnable parameters in the `B` matrix.</span>

<span class="sd">        zeta: 2-D array (boolean)</span>
<span class="sd">            The learnable parameters in the covariance matrix of the error terms.</span>

<span class="sd">        wedge_y: 2-D array</span>
<span class="sd">            The `wedge_y` matrix.</span>

<span class="sd">        fixed_params: dict (default: None)</span>
<span class="sd">            A dict of fixed values for parameters.</span>

<span class="sd">            If None all the parameters specified by `B`, and `zeta` are learnable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEMAlg instance: An instance of the object with initalized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span> <span class="o">=</span> <span class="n">wedge_y</span>

        <span class="c1"># Get the observed variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="p">[</span><span class="n">row_i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fixed_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">fixed_values</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">fixed_values</span><span class="p">[</span><span class="s2">&quot;zeta&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Masks represent the parameters which need to be learnt while training.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SEMAlg.to_SEMGraph">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.to_SEMGraph">[docs]</a>
    <span class="k">def</span> <span class="nf">to_SEMGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a graph structure from the LISREL representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEMGraph instance: A path model of the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        &gt;&gt;&gt; model = SEMAlg()</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">err_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)}</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">),</span>
            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])},</span>
        <span class="p">)</span>
        <span class="c1"># Fill zeta diagonal with 0&#39;s as they represent variance and would add self loops in the graph.</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">zeta</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">),</span>
            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])},</span>
        <span class="p">)</span>

        <span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pgmpy.models</span> <span class="kn">import</span> <span class="n">SEMGraph</span>

        <span class="c1"># TODO: Add edge weights</span>
        <span class="n">sem_graph</span> <span class="o">=</span> <span class="n">SEMGraph</span><span class="p">(</span>
            <span class="n">ebunch</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span>
            <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span>
            <span class="n">err_corr</span><span class="o">=</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span>
            <span class="n">err_var</span><span class="o">=</span><span class="n">err_var</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sem_graph</span></div>


<div class="viewcode-block" id="SEMAlg.set_params">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.set_params">[docs]</a>
    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">zeta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the fixed parameters of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B: 2D array</span>
<span class="sd">            The B matrix.</span>

<span class="sd">        zeta: 2D array</span>
<span class="sd">            The covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">zeta</span></div>


<div class="viewcode-block" id="SEMAlg.generate_samples">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.generate_samples">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates random samples from the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_samples: int</span>
<span class="sd">            The number of samples to generate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame: The generated samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters for the model has not been specified.&quot;</span><span class="p">)</span>

        <span class="n">B_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span><span class="p">)</span>
        <span class="n">implied_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span> <span class="o">@</span> <span class="n">B_inv</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">@</span> <span class="n">B_inv</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>

        <span class="c1"># Check if implied covariance matrix is positive definite.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">implied_cov</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The implied covariance matrix is not positive definite.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Please check model parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get the order of observed variables</span>
        <span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y_index</span><span class="p">]</span>

        <span class="c1"># Generate samples and return a dataframe.</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">implied_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
            <span class="n">cov</span><span class="o">=</span><span class="n">implied_cov</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">observed</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SEM">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM">[docs]</a>
<span class="k">class</span> <span class="nc">SEM</span><span class="p">(</span><span class="n">SEMGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for representing Structural Equation Models. This class is a wrapper over</span>
<span class="sd">    `SEMGraph` and `SEMAlg` to provide a consistent API over the different representations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model: SEMGraph instance</span>
<span class="sd">        A graphical representation of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syntax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a `SEM` object. Preferred way to initialize the object is to use one of</span>
<span class="sd">        the `from_lavaan`, `from_graph`, `from_lisrel`, or `from_RAM` methods.</span>

<span class="sd">        There are three possible ways to initialize the model:</span>
<span class="sd">            1. Lavaan syntax: `lavaan_str` needs to be specified.</span>
<span class="sd">            2. Graph structure: `ebunch`, `latents`, `err_corr`, and `err_var` need to be specified.</span>
<span class="sd">            3. LISREL syntax: `var_names`, `params`, and `fixed_masks` need to be specified.</span>
<span class="sd">            4. Reticular Action Model (RAM/all-y) syntax: `var_names`, `B`, `zeta`, and `wedge_y`</span>
<span class="sd">                                                            need to be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        syntax: str (lavaan|graph|lisrel|ram)</span>
<span class="sd">            The syntax used to initialize the model.</span>

<span class="sd">        kwargs:</span>
<span class="sd">            For parameter details, check docstrings for `from_lavaan`, `from_graph`, `from_lisrel`,</span>
<span class="sd">            and `from_RAM` methods.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_lavaan: Initialize a model using lavaan syntax.</span>
<span class="sd">        from_graph: Initialize a model using graph structure.</span>
<span class="sd">        from_lisrel: Initialize a model using LISREL syntax.</span>
<span class="sd">        from_RAM: Initialize a model using Reticular Action Model(RAM/all-y) syntax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lavaan&quot;</span><span class="p">:</span>
            <span class="c1"># Create a SEMGraph model using the lavaan str.</span>
            <span class="c1"># Step 0: Check if pyparsing is installed</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pyparsing</span> <span class="kn">import</span> <span class="p">(</span>
                    <span class="n">OneOrMore</span><span class="p">,</span>
                    <span class="n">Optional</span><span class="p">,</span>
                    <span class="n">Suppress</span><span class="p">,</span>
                    <span class="n">Word</span><span class="p">,</span>
                    <span class="n">alphanums</span><span class="p">,</span>
                    <span class="n">nums</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">msg</span>
                    <span class="o">+</span> <span class="s2">&quot;. pyparsing is required for using lavaan syntax. Please install using: pip install pyparsing&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Step 1: Define the grammar for each type of string.</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphanums</span><span class="p">)</span>
            <span class="n">reg_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;predictors&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;covariates&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">intercept_gram</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s2">&quot;inter_var&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;~&quot;</span> <span class="o">+</span> <span class="n">Word</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">covar_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">var</span><span class="p">(</span><span class="s2">&quot;covar_var1&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;~~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;covar_var2&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">latent_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">var</span><span class="p">(</span><span class="s2">&quot;latent&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;=~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Step 2: Preprocess string to lines</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lavaan_str&quot;</span><span class="p">]</span>

            <span class="c1"># Step 3: Initialize arguments and fill them by parsing each line.</span>
            <span class="n">ebunch</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">latents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">err_corr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">err_var</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">intercept_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">reg_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">reg_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;predictors&quot;</span><span class="p">]:</span>
                            <span class="n">ebunch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="p">(</span><span class="n">covariate</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">covariate</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;covariates&quot;</span><span class="p">]</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">covar_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">covar_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;covar_var2&quot;</span><span class="p">]:</span>
                            <span class="n">err_corr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;covar_var1&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">latent_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">latent_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">latents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;latent&quot;</span><span class="p">])</span>
                        <span class="n">ebunch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;latent&quot;</span><span class="p">],</span> <span class="n">obs</span><span class="p">)</span> <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">]]</span>
                        <span class="p">)</span>

            <span class="c1"># Step 4: Call the parent __init__ with the arguments</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="n">ebunch</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span> <span class="n">err_corr</span><span class="o">=</span><span class="n">err_corr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;graph&quot;</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">ebunch</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ebunch&quot;</span><span class="p">],</span>
                <span class="n">latents</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latents&quot;</span><span class="p">],</span>
                <span class="n">err_corr</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;err_corr&quot;</span><span class="p">],</span>
                <span class="n">err_var</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;err_var&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lisrel&quot;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">SEMAlg</span><span class="p">(</span>
                <span class="n">var_names</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="o">=</span><span class="n">fixed_masks</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to_SEMGraph</span><span class="p">()</span>
            <span class="c1"># Initialize an empty SEMGraph instance and set the properties.</span>
            <span class="c1"># TODO: Boilerplate code, find a better way to do this.</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">latents</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obseved</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">observed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">err_graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">full_graph_struct</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ram&quot;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">SEMAlg</span><span class="p">(</span>
                <span class="n">eta</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;var_names&quot;</span><span class="p">],</span>
                <span class="n">B</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span>
                <span class="n">zeta</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;zeta&quot;</span><span class="p">],</span>
                <span class="n">wedge_y</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span>
                <span class="n">fixed_values</span><span class="o">=</span><span class="n">fixed_masks</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SEM.from_lavaan">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_lavaan">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_lavaan</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using lavaan syntax.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string: str (default: None)</span>
<span class="sd">            A `lavaan` style multiline set of regression equation representing the model.</span>
<span class="sd">            Refer http://lavaan.ugent.be/tutorial/syntax1.html for details.</span>

<span class="sd">        filename: str (default: None)</span>
<span class="sd">            The filename of the file containing the model in lavaan syntax.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">lavaan_str</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span><span class="p">:</span>
            <span class="n">lavaan_str</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either `filename` or `string` need to be specified&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;lavaan&quot;</span><span class="p">,</span> <span class="n">lavaan_str</span><span class="o">=</span><span class="n">lavaan_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="SEM.from_graph">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_graph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_graph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ebunch</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using graphical structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebunch: list/array-like</span>
<span class="sd">            List of edges in form of tuples. Each tuple can be of two possible shape:</span>
<span class="sd">                1. (u, v): This would add an edge from u to v without setting any parameter</span>
<span class="sd">                           for the edge.</span>
<span class="sd">                2. (u, v, parameter): This would add an edge from u to v and set the edge&#39;s</span>
<span class="sd">                            parameter to `parameter`.</span>

<span class="sd">        latents: list/array-like</span>
<span class="sd">            List of nodes which are latent. All other variables are considered observed.</span>

<span class="sd">        err_corr: list/array-like</span>
<span class="sd">            List of tuples representing edges between error terms. It can be of the following forms:</span>
<span class="sd">                1. (u, v): Add correlation between error terms of `u` and `v`. Doesn&#39;t set any variance or</span>
<span class="sd">                           covariance values.</span>
<span class="sd">                2. (u, v, covar): Adds correlation between the error terms of `u` and `v` and sets the</span>
<span class="sd">                                  parameter to `covar`.</span>

<span class="sd">        err_var: dict</span>
<span class="sd">            Dict of the form (var: variance).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Defining a model (Union sentiment model[1]) without setting any paramaters.</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; sem = SEM.from_graph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                              (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                              (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                      latents=[],</span>
<span class="sd">        ...                      err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">        ...                      err_var={})</span>

<span class="sd">        Defining a model (Education [2]) with all the parameters set. For not setting any</span>
<span class="sd">        parameter `np.nan` can be explicitly passed.</span>
<span class="sd">        &gt;&gt;&gt; sem_edu = SEM.from_graph(ebunch=[(&#39;intelligence&#39;, &#39;academic&#39;, 0.8), (&#39;intelligence&#39;, &#39;scale_1&#39;, 0.7),</span>
<span class="sd">        ...                                  (&#39;intelligence&#39;, &#39;scale_2&#39;, 0.64), (&#39;intelligence&#39;, &#39;scale_3&#39;, 0.73),</span>
<span class="sd">        ...                                  (&#39;intelligence&#39;, &#39;scale_4&#39;, 0.82), (&#39;academic&#39;, &#39;SAT_score&#39;, 0.98),</span>
<span class="sd">        ...                                  (&#39;academic&#39;, &#39;High_school_gpa&#39;, 0.75), (&#39;academic&#39;, &#39;ACT_score&#39;, 0.87)],</span>
<span class="sd">        ...                          latents=[&#39;intelligence&#39;, &#39;academic&#39;],</span>
<span class="sd">        ...                          err_corr=[],</span>
<span class="sd">        ...                          err_var={})</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] McDonald, A, J., &amp; Clelland, D. A. (1984). Textile Workers and Union Sentiment.</span>
<span class="sd">            Social Forces, 63(2), 502â€“521</span>
<span class="sd">        [2] https://en.wikipedia.org/wiki/Structural_equation_modeling#/</span>
<span class="sd">            media/File:Example_Structural_equation_model.svg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span>
            <span class="n">ebunch</span><span class="o">=</span><span class="n">ebunch</span><span class="p">,</span>
            <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span>
            <span class="n">err_corr</span><span class="o">=</span><span class="n">err_corr</span><span class="p">,</span>
            <span class="n">err_var</span><span class="o">=</span><span class="n">err_var</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SEM.from_lisrel">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_lisrel">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_lisrel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using LISREL notation. The LISREL notation is defined as:</span>
<span class="sd">        ..math::</span>

<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\Gamma \xi} + mathbf{\zeta} \\</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{x} = \mathbf{\wedge_x \xi} + \mathbf{\delta}</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of endogenous variables, :math:`\mathbf{\xi}`</span>
<span class="sd">        is the set of exogeneous variables, :math:`\mathbf{y}` and :math:`\mathbf{x}` are the</span>
<span class="sd">        set of measurement variables for :math:`\mathbf{\eta}` and :math:`\mathbf{\xi}`</span>
<span class="sd">        respectively. :math:`\mathbf{\zeta}`, :math:`\mathbf{\epsilon}`, and :math:`\mathbf{\delta}`</span>
<span class="sd">        are the error terms for :math:`\mathbf{\eta}`, :math:`\mathbf{y}`, and :math:`\mathbf{x}`</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        str_model: str (default: None)</span>
<span class="sd">            A `lavaan` style multiline set of regression equation representing the model.</span>
<span class="sd">            Refer http://lavaan.ugent.be/tutorial/syntax1.html for details.</span>

<span class="sd">            If None requires `var_names` and `params` to be specified.</span>

<span class="sd">        var_names: dict (default: None)</span>
<span class="sd">            A dict with the keys: eta, xi, y, and x. Each keys should have a list as the value</span>
<span class="sd">            with the name of variables.</span>

<span class="sd">        params: dict (default: None)</span>
<span class="sd">            A dict of LISREL representation non-zero parameters. Must contain the following</span>
<span class="sd">            keys: B, gamma, wedge_y, wedge_x, phi, theta_e, theta_del, and psi.</span>

<span class="sd">            If None `str_model` must be specified.</span>

<span class="sd">        fixed_params: dict (default: None)</span>
<span class="sd">            A dict of fixed values for parameters. The shape of the parameters should be same</span>
<span class="sd">            as params.</span>

<span class="sd">            If None all the parameters are learnable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEM instance: An instance of the object with initalized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;wedge_x&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta_e&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta_del&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;psi&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;wedge_x&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;theta_e&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;theta_del&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;psi&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_RAM</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="s2">&quot;zeta&quot;</span><span class="p">:</span> <span class="n">zeta</span><span class="p">},</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SEM.from_RAM">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_RAM">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_RAM</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wedge_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using Reticular Action Model(RAM) notation. The model</span>
<span class="sd">        is defined as:</span>

<span class="sd">        ..math::</span>

<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{\y} = \wedge_y \mathbf{\eta}</span>
<span class="sd">            \zeta = COV(\mathbf{\epsilon})</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of variables (both latent and observed),</span>
<span class="sd">        :math:`\mathbf{\epsilon}` are the error terms, :math:`\mathbf{y}` is the set</span>
<span class="sd">        of observed variables, :math:`\wedge_y` is a boolean array of the shape (no of</span>
<span class="sd">        observed variables, no of total variables).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: list, array-like</span>
<span class="sd">            List of variables (both latent and observed) in the model.</span>

<span class="sd">        B: 2-D boolean array (shape: `len(variables)` x `len(variables)`)</span>
<span class="sd">            The non-zero parameters in :math:`B` matrix. Refer model definition in docstring for details.</span>

<span class="sd">        zeta: 2-D boolean array (shape: `len(variables)` x `len(variables)`)</span>
<span class="sd">            The non-zero parameters in :math:`\zeta` (error covariance) matrix. Refer model definition</span>
<span class="sd">            in docstring for details.</span>

<span class="sd">        observed: list, array-like (optional: Either `observed` or `wedge_y` needs to be specified)</span>
<span class="sd">            List of observed variables in the model.</span>

<span class="sd">        wedge_y: 2-D array (shape: no. observed x total vars) (optional: Either `observed` or `wedge_y`)</span>
<span class="sd">            The :math:`\wedge_y` matrix. Refer model definition in docstring for details.</span>

<span class="sd">        fixed_values: dict (optional)</span>
<span class="sd">            If specified, fixes the parameter values and are not changed during estimation.</span>
<span class="sd">            A dict with the keys B, zeta.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEM instance: An instance of the object with initialized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; SEM.from_RAM  # TODO: Finish this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
            <span class="n">wedge_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)))</span>
            <span class="n">obs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observed</span><span class="p">)}</span>
            <span class="n">all_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variables</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                <span class="n">wedge_y</span><span class="p">[</span><span class="n">obs_dict</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">all_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;ram&quot;</span><span class="p">,</span>
            <span class="n">var_names</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span>
            <span class="n">wedge_y</span><span class="o">=</span><span class="n">wedge_y</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SEM.fit">
<a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../started/base.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html">Base Model Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/base.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/base.html">Parameterization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/base.html">Exact Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/model_testing.html">Model Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/base.html">Approximate Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/base.html">Parameter Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/base.html">Structure Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metrics/metrics.html">Metrics for testing models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/base.html">Reading/Writing to File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plotting.html">Plotting Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial Notebooks</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>







<script async src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>

<div data-ea-publisher="pgmpyorg" data-ea-type="image" data-ea-style="horizontal"></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-HCFR07M31W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HCFR07M31W');
</script>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2023, Ankur Ankan.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>
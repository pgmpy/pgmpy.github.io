<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pgmpy.models.SEM &mdash; pgmpy 0.1.19 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> pgmpy
          </a>
              <div class="version">
                dev branch
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../started/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/contributing.html">Contributing to pgmpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Base Structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html">Directed Acyclic Graph (DAG)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html#partial-directed-acyclic-graph-pdag">Partial Directed Acyclic Graph (PDAG)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/bayesiannetwork.html">Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/dbn.html">Dynamic Bayesian Network (DBN)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/sem.html">Structural Equation Models (SEM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/naive.html">Naive Bayes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/noisyor.html">NoisyOr Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/markovnetwork.html">Markov Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/junctiontree.html">Junction Tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/clustergraph.html">Cluster Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/factorgraph.html">Factor Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/markovchain.html">Markov Chain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parameterization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/discrete.html">Discrete</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/discretize.html">Discretizing Methods</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact Inference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/ve.html">Variable Elimination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/ve.html#module-pgmpy.inference.EliminationOrder">Elimination Ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/bp.html">Belief Propagation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/causal.html">Causal Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/mplp.html">MPLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/dbn_infer.html">Dynamic Bayesian Network Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/model_testing.html">Model Testing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Approximate Inference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/approx_infer.html">Approximate Inference Using Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/bn_sampling.html">Bayesian Model Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/gibbs.html">Gibbs Sampling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parameter Estimation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/mle.html">Maximum Likelihood Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/bayesian_est.html">Bayesian Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/em.html">Expectation Maximization (EM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/sem_estimator.html">Structural Equation Model Estimators</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Structure Learning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/pc.html">PC (Constraint-Based Estimator)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/pc.html#module-pgmpy.estimators.CITests">Conditional Independence Tests for PC algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/hill.html">Hill Climb Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/hill.html#structure-score">Structure Score</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/tree.html">Tree Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/mmhc.html">Mmhc Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/exhaustive.html">Exhaustive Search</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Model Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../metrics/metrics.html">Metrics for testing models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/bif.html">BIF (Bayesian Interchange Format)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/uai.html">UAI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/xmlbif.html">XMLBIF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/pomdpx.html">PomdpX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/xmlbelief.html">XMLBeliefNetwork</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Earthquake.html">1. Example Using the Earthquake network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Monty%20Hall%20Problem.html">2. Monty Hall Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Creating%20a%20Discrete%20Bayesian%20Network.html">3. Creating discrete Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Inference%20in%20Discrete%20Bayesian%20Networks.html">4. Inference in Discrete Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Causal%20Games.html">5. Causal Games</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Causal%20Inference.html">6. Causal Inference Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Learning%20Parameters%20in%20Discrete%20Bayesian%20Networks.html">7. Parameter Learning in Discrete Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20in%20Bayesian%20Networks.html">8. Structure Learning in Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20with%20Chow-Liu.html">9. Learning Tree Structure from Data using the Chow-Liu Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20with%20TAN.html">10. Learning Tree-augmented Naive Bayes (TAN) Structure from Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Simulating%20Data.html">11. Normal Bayesian Network (no time variation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Extending%20pgmpy.html">12. Extending pgmpy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/1.%20Introduction%20to%20Probabilistic%20Graphical%20Models.html">1. Introduction to Probabilitic Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/2.%20Bayesian%20Networks.html">2. Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/3.%20Causal%20Bayesian%20Networks.html">3. Causal Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/4.%20Markov%20Models.html">4. Markov Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/5.%20Exact%20Inference%20in%20Graphical%20Models.html">5. Exact Inference in Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/6.%20Approximate%20Inference%20in%20Graphical%20Models.html">6. Approximate Inference in Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/7.%20Parameterizing%20with%20Continuous%20Variables.html">7. Parameterizing with Continuous Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/8.%20Sampling%20Algorithms.html">8. Sampling In Continuous Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/9.%20Reading%20and%20Writing%20from%20pgmpy%20file%20formats.html">9. Reading and Writing from pgmpy file formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/10.%20Learning%20Bayesian%20Networks%20from%20Data.html">10. Learning Bayesian Networks from Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/11.%20A%20Bayesian%20Network%20to%20model%20the%20influence%20of%20energy%20consumption%20on%20greenhouse%20gases%20in%20Italy.html">11. A Bayesian Network to model the influence of energy consumption on greenhouse gases in Italy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pgmpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>pgmpy.models.SEM</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pgmpy.models.SEM</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">networkx.algorithms.dag</span> <span class="kn">import</span> <span class="n">descendants</span>
<span class="kn">from</span> <span class="nn">pyparsing</span> <span class="kn">import</span> <span class="n">OneOrMore</span><span class="p">,</span> <span class="n">Word</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">,</span> <span class="n">alphanums</span><span class="p">,</span> <span class="n">nums</span>

<span class="kn">from</span> <span class="nn">pgmpy.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="kn">from</span> <span class="nn">pgmpy.global_vars</span> <span class="kn">import</span> <span class="n">HAS_PANDAS</span>


<span class="k">if</span> <span class="n">HAS_PANDAS</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<div class="viewcode-block" id="SEMGraph"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph">[docs]</a><span class="k">class</span> <span class="nc">SEMGraph</span><span class="p">(</span><span class="n">DAG</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for graphical representation of Structural Equation Models(SEMs).</span>

<span class="sd">    All variables are by default assumed to have an associated error latent variable, therefore</span>
<span class="sd">    doesn&#39;t need to be specified.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    latents: list</span>
<span class="sd">        List of all the latent variables in the model except the error terms.</span>

<span class="sd">    observed: list</span>
<span class="sd">        List of all the observed variables in the model.</span>

<span class="sd">    graph: nx.DirectedGraph</span>
<span class="sd">        The graphical structure of the latent and observed variables except the error terms.</span>
<span class="sd">        The parameters are stored in the `weight` attribute of each edge.</span>

<span class="sd">    err_graph: nx.Graph</span>
<span class="sd">        An undirected graph representing the relations between the error terms of the model.</span>
<span class="sd">        The node of the graph has the same name as the variable but represents the error terms.</span>
<span class="sd">        The variance is stored in the `weight` attribute of the node and the covariance are stored</span>
<span class="sd">        in the `weight` attribute of the edge.</span>

<span class="sd">    full_graph_struct: nx.DiGraph</span>
<span class="sd">        Represents the full graph structure. The names of error terms start with `.` and</span>
<span class="sd">        new nodes are added for each correlation which starts with `..`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEMGraph` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebunch: list/array-like</span>
<span class="sd">            List of edges in form of tuples. Each tuple can be of two possible shape:</span>
<span class="sd">                1. (u, v): This would add an edge from u to v without setting any parameter</span>
<span class="sd">                           for the edge.</span>
<span class="sd">                2. (u, v, parameter): This would add an edge from u to v and set the edge&#39;s</span>
<span class="sd">                            parameter to `parameter`.</span>

<span class="sd">        latents: list/array-like</span>
<span class="sd">            List of nodes which are latent. All other variables are considered observed.</span>

<span class="sd">        err_corr: list/array-like</span>
<span class="sd">            List of tuples representing edges between error terms. It can be of the following forms:</span>
<span class="sd">                1. (u, v): Add correlation between error terms of `u` and `v`. Doesn&#39;t set any variance or</span>
<span class="sd">                           covariance values.</span>
<span class="sd">                2. (u, v, covar): Adds correlation between the error terms of `u` and `v` and sets the</span>
<span class="sd">                                  parameter to `covar`.</span>

<span class="sd">        err_var: dict (variable: variance)</span>
<span class="sd">            Sets variance for the error terms in the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Defining a model (Union sentiment model[1]) without setting any paramaters.</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; sem = SEMGraph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                        (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                        (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                latents=[],</span>
<span class="sd">        ...                err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">        ...                err_var={})</span>

<span class="sd">        Defining a model (Education [2]) with all the parameters set. For not setting any</span>
<span class="sd">        parameter `np.NaN` can be explicitly passed.</span>
<span class="sd">        &gt;&gt;&gt; sem_edu = SEMGraph(ebunch=[(&#39;intelligence&#39;, &#39;academic&#39;, 0.8), (&#39;intelligence&#39;, &#39;scale_1&#39;, 0.7),</span>
<span class="sd">        ...                            (&#39;intelligence&#39;, &#39;scale_2&#39;, 0.64), (&#39;intelligence&#39;, &#39;scale_3&#39;, 0.73),</span>
<span class="sd">        ...                            (&#39;intelligence&#39;, &#39;scale_4&#39;, 0.82), (&#39;academic&#39;, &#39;SAT_score&#39;, 0.98),</span>
<span class="sd">        ...                            (&#39;academic&#39;, &#39;High_school_gpa&#39;, 0.75), (&#39;academic&#39;, &#39;ACT_score&#39;, 0.87)],</span>
<span class="sd">        ...                    latents=[&#39;intelligence&#39;, &#39;academic&#39;],</span>
<span class="sd">        ...                    err_corr=[],</span>
<span class="sd">        ...                    err_var={&#39;intelligence&#39;: 1})</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] McDonald, A, J., &amp; Clelland, D. A. (1984). Textile Workers and Union Sentiment.</span>
<span class="sd">            Social Forces, 63(2), 502â€“521</span>
<span class="sd">        [2] https://en.wikipedia.org/wiki/Structural_equation_modeling#/</span>
<span class="sd">            media/File:Example_Structural_equation_model.svg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SEMGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Construct the graph and set the parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ebunch</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected tuple length: 2 or 3. Got </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> of len </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="c1"># Construct the error graph and set the parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">err_corr</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected tuple length: 2 or 3. Got </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> of len </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Set the error variances</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">err_var</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">err_var</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_full_graph_struct</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_full_graph_struct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a directed graph by joining `self.graph` and `self.err_graph`.</span>
<span class="sd">        Adds new nodes to replace undirected edges (u &lt;--&gt; v) with two directed</span>
<span class="sd">        edges (u &lt;-- ..uv) and (..uv --&gt; v).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.DiGraph: A full directed graph strucuture with error nodes starting</span>
<span class="sd">                    with `.` and bidirected edges replaced with common cause</span>
<span class="sd">                    nodes starting with `..`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; sem = SEMGraph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                        (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                        (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                latents=[],</span>
<span class="sd">        ...                err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; sem._get_full_graph_struct()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">mapping_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
        <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">cov_node</span> <span class="o">=</span> <span class="s2">&quot;..&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]))</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">cov_node</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">u</span><span class="p">),</span> <span class="p">(</span><span class="n">cov_node</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">full_graph</span>

<div class="viewcode-block" id="SEMGraph.get_scaling_indicators"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_scaling_indicators">[docs]</a>    <span class="k">def</span> <span class="nf">get_scaling_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a scaling indicator for each of the latent variables in the model.</span>
<span class="sd">        The scaling indicator is chosen randomly among the observed measurement</span>
<span class="sd">        variables of the latent variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;xi1&#39;, &#39;eta1&#39;), (&#39;xi1&#39;, &#39;x1&#39;), (&#39;xi1&#39;, &#39;x2&#39;),</span>
<span class="sd">        ...                          (&#39;eta1&#39;, &#39;y1&#39;), (&#39;eta1&#39;, &#39;y2&#39;)],</span>
<span class="sd">        ...                  latents=[&#39;xi1&#39;, &#39;eta1&#39;])</span>
<span class="sd">        &gt;&gt;&gt; model.get_scaling_indicators()</span>
<span class="sd">        {&#39;xi1&#39;: &#39;x1&#39;, &#39;eta1&#39;: &#39;y1&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict: Returns a dict with latent variables as the key and their value being the</span>
<span class="sd">                scaling indicator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">:</span>
                    <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">scaling_indicators</span></div>

<div class="viewcode-block" id="SEMGraph.active_trail_nodes"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.active_trail_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">active_trail_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="p">[],</span> <span class="n">avoid_nodes</span><span class="o">=</span><span class="p">[],</span> <span class="n">struct</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the observed variables which are d-connected to `variables` in the `graph_struct`</span>
<span class="sd">        when `observed` variables are observed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            Observed variables whose d-connected variables are to be found.</span>

<span class="sd">        observed : list/array-like</span>
<span class="sd">            If given the active trails would be computed assuming these nodes to be observed.</span>

<span class="sd">        avoid_nodes: list/array-like</span>
<span class="sd">            If specificed, the algorithm doesn&#39;t account for paths that have influence flowing</span>
<span class="sd">            through the avoid node.</span>

<span class="sd">        struct: str or nx.DiGraph instance</span>
<span class="sd">            If &quot;full&quot;, considers correlation between error terms for computing d-connection.</span>
<span class="sd">            If &quot;non_error&quot;, doesn&#39;t condised error correlations for computing d-connection.</span>
<span class="sd">            If instance of nx.DiGraph, finds d-connected variables on the given graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;laboract&#39;),</span>
<span class="sd">        ...                          (&#39;age&#39;, &#39;deferenc&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;),</span>
<span class="sd">        ...                          (&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.active_trail_nodes(&#39;age&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict: {str: list}</span>
<span class="sd">            Returns a dict with `variables` as the key and a list of d-connected variables as the</span>
<span class="sd">            value.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Details of the algorithm can be found in &#39;Probabilistic Graphical Model</span>
<span class="sd">        Principles and Techniques&#39; - Koller and Friedman</span>
<span class="sd">        Page 75 Algorithm 3.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">struct</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span>
        <span class="k">elif</span> <span class="n">struct</span> <span class="o">==</span> <span class="s2">&quot;non_error&quot;</span><span class="p">:</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="n">graph_struct</span> <span class="o">=</span> <span class="n">struct</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected struct to be str or nx.DiGraph. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
            <span class="n">ancestors_list</span> <span class="o">=</span> <span class="n">ancestors_list</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph_struct</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Direction of flow of information</span>
        <span class="c1"># up -&gt;  from parent to child</span>
        <span class="c1"># down -&gt; from child to parent</span>

        <span class="n">active_trails</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]:</span>
            <span class="n">visit_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">traversed_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">active_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">visit_list</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">visit_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">avoid_nodes</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traversed_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">active_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">traversed_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">graph_struct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span>
        <span class="k">return</span> <span class="n">active_trails</span></div>

    <span class="k">def</span> <span class="nf">_iv_transformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the graph structure of SEM so that the d-separation criterion is</span>
<span class="sd">        applicable for finding IVs. The method transforms the graph for finding MIIV</span>
<span class="sd">        for the estimation of X \rightarrow Y given the scaling indicator for all the</span>
<span class="sd">        parent latent variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The explantory variable.</span>

<span class="sd">        Y: node</span>
<span class="sd">            The dependent variable.</span>

<span class="sd">        scaling_indicators: dict</span>
<span class="sd">            Scaling indicator for each latent variable in the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.DiGraph: The transformed full graph structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;xi1&#39;, &#39;eta1&#39;), (&#39;xi1&#39;, &#39;x1&#39;), (&#39;xi1&#39;, &#39;x2&#39;),</span>
<span class="sd">        ...                          (&#39;eta1&#39;, &#39;y1&#39;), (&#39;eta1&#39;, &#39;y2&#39;)],</span>
<span class="sd">        ...                  latents=[&#39;xi1&#39;, &#39;eta1&#39;])</span>
<span class="sd">        &gt;&gt;&gt; model._iv_transformations(&#39;xi1&#39;, &#39;eta1&#39;,</span>
<span class="sd">        ...                           scaling_indicators={&#39;xi1&#39;: &#39;x1&#39;, &#39;eta1&#39;: &#39;y1&#39;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">full_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The edge from </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> doesn&#39;t exist in the graph&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_graph</span><span class="p">,</span> <span class="n">Y</span>

        <span class="k">elif</span> <span class="n">Y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">Y</span><span class="p">])</span>
            <span class="n">dependent_var</span> <span class="o">=</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dependent_var</span> <span class="o">=</span> <span class="n">Y</span>

        <span class="k">for</span> <span class="n">parent_y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="c1"># Remove edge even when the parent is observed ????</span>
            <span class="n">full_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent_y</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
                <span class="n">full_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">parent_y</span><span class="p">],</span> <span class="n">dependent_var</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">full_graph</span><span class="p">,</span> <span class="n">dependent_var</span>

<div class="viewcode-block" id="SEMGraph.get_ivs"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_ivs">[docs]</a>    <span class="k">def</span> <span class="nf">get_ivs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Instrumental variables(IVs) for the relation X -&gt; Y</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The variable name (observed or latent)</span>

<span class="sd">        Y: node</span>
<span class="sd">            The variable name (observed or latent)</span>

<span class="sd">        scaling_indicators: dict (optional)</span>
<span class="sd">            A dict representing which observed variable to use as scaling indicator for</span>
<span class="sd">            the latent variables.</span>
<span class="sd">            If not given the method automatically selects one of the measurement variables</span>
<span class="sd">            at random as the scaling indicator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set: {str}</span>
<span class="sd">            The set of Instrumental Variables for X -&gt; Y.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;I&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;X&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.get_ivs(&#39;X&#39;, &#39;Y&#39;)</span>
<span class="sd">        {&#39;I&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaling_indicators</span><span class="p">:</span>
            <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaling_indicators</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">scaling_indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">Y</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> is the scaling indicator of </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">. Please specify `scaling_indicators`&quot;</span>
            <span class="p">)</span>

        <span class="n">transformed_graph</span><span class="p">,</span> <span class="n">dependent_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iv_transformations</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="n">scaling_indicators</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
            <span class="n">explanatory_var</span> <span class="o">=</span> <span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">explanatory_var</span> <span class="o">=</span> <span class="n">X</span>

        <span class="n">d_connected_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
            <span class="p">[</span><span class="n">explanatory_var</span><span class="p">],</span> <span class="n">struct</span><span class="o">=</span><span class="n">transformed_graph</span>
        <span class="p">)[</span><span class="n">explanatory_var</span><span class="p">]</span>

        <span class="c1"># Condition on X to block any paths going through X.</span>
        <span class="n">d_connected_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
            <span class="p">[</span><span class="n">dependent_var</span><span class="p">],</span> <span class="n">avoid_nodes</span><span class="o">=</span><span class="p">[</span><span class="n">explanatory_var</span><span class="p">],</span> <span class="n">struct</span><span class="o">=</span><span class="n">transformed_graph</span>
        <span class="p">)[</span><span class="n">dependent_var</span><span class="p">]</span>

        <span class="c1"># Remove {X, Y} because they can&#39;t be IV for X -&gt; Y</span>
        <span class="k">return</span> <span class="n">d_connected_x</span> <span class="o">-</span> <span class="n">d_connected_y</span> <span class="o">-</span> <span class="p">{</span><span class="n">dependent_var</span><span class="p">,</span> <span class="n">explanatory_var</span><span class="p">}</span></div>

<div class="viewcode-block" id="SEMGraph.moralize"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.moralize">[docs]</a>    <span class="k">def</span> <span class="nf">moralize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO: This needs to go to a parent class.</span>
<span class="sd">        Removes all the immoralities in the DirectedGraph and creates a moral</span>
<span class="sd">        graph (UndirectedGraph).</span>

<span class="sd">        A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge</span>
<span class="sd">        between X and Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        graph:</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>

        <span class="n">moral_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">moral_graph</span></div>

    <span class="k">def</span> <span class="nf">_nearest_separator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the set of the nearest separators for `Y` and `Z` in `G`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G: nx.DiGraph instance</span>
<span class="sd">            The graph in which to the find the nearest separation for `Y` and `Z`.</span>

<span class="sd">        Y: str</span>
<span class="sd">            The variable name for which the separators are needed.</span>

<span class="sd">        Z: str</span>
<span class="sd">            The other variable for which the separators are needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set or None: If there is a nearest separator returns the set of separators else returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ancestral_G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">})</span>
        <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Optimization: Remove all error nodes which don&#39;t have any correlation as it doesn&#39;t add any new path. If not removed it can create a lot of</span>
        <span class="c1"># extra paths resulting in a much higher runtime.</span>
        <span class="n">err_nodes_to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">ancestral_G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">err_nodes_to_remove</span><span class="p">])</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moralize</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">ancestral_G</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">Y</span><span class="p">])</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>

        <span class="c1"># Another optimization over the original algo. Rather than going through all the paths does</span>
        <span class="c1"># a DFS search to find a markov blanket of observed variables. This doesn&#39;t ensure minimal observed</span>
        <span class="c1"># set.</span>
        <span class="k">while</span> <span class="n">to_visit</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">Z</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">:</span>
                <span class="n">W</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_visit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="c1"># for path in nx.all_simple_paths(M, Y, Z):</span>
        <span class="c1">#     path_set = set(path)</span>
        <span class="c1">#     if (len(path) &gt;= 3) and not (W &amp; path_set):</span>
        <span class="c1">#         for index in range(1, len(path)-1):</span>
        <span class="c1">#             if path[index] in self.observed:</span>
        <span class="c1">#                 W.add(path[index])</span>
        <span class="c1">#                 break</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">struct</span><span class="o">=</span><span class="n">ancestral_G</span><span class="p">)[</span><span class="n">Z</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">W</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="SEMGraph.get_conditional_ivs"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.get_conditional_ivs">[docs]</a>    <span class="k">def</span> <span class="nf">get_conditional_ivs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the conditional IVs for the relation X -&gt; Y</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: node</span>
<span class="sd">            The observed variable&#39;s name</span>

<span class="sd">        Y: node</span>
<span class="sd">            The oberved variable&#39;s name</span>

<span class="sd">        scaling_indicators: dict (optional)</span>
<span class="sd">            A dict representing which observed variable to use as scaling indicator for</span>
<span class="sd">            the latent variables.</span>
<span class="sd">            If not provided, automatically finds scaling indicators by randomly selecting</span>
<span class="sd">            one of the measurement variables of each latent variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set: Set of 2-tuples representing tuple[0] is an IV for X -&gt; Y given tuple[1].</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Van Der Zander, B., Textor, J., &amp; Liskiewicz, M. (2015, June). Efficiently finding</span>
<span class="sd">               conditional instruments for causal inference. In Twenty-Fourth International Joint</span>
<span class="sd">               Conference on Artificial Intelligence.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMGraph</span>
<span class="sd">        &gt;&gt;&gt; model = SEMGraph(ebunch=[(&#39;I&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;), (&#39;W&#39;, &#39;I&#39;)],</span>
<span class="sd">        ...                  latents=[],</span>
<span class="sd">        ...                  err_corr=[(&#39;W&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model.get_ivs(&#39;X&#39;, &#39;Y&#39;)</span>
<span class="sd">        [(&#39;I&#39;, {&#39;W&#39;})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaling_indicators</span><span class="p">:</span>
            <span class="n">scaling_indicators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaling_indicators</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">scaling_indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scaling_indicators</span><span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">==</span> <span class="n">Y</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Y</span><span class="si">}</span><span class="s2"> is the scaling indicator of </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">. Please specify `scaling_indicators`&quot;</span>
            <span class="p">)</span>

        <span class="n">transformed_graph</span><span class="p">,</span> <span class="n">dependent_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iv_transformations</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">scaling_indicators</span><span class="o">=</span><span class="n">scaling_indicators</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">transformed_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">G_c</span> <span class="o">=</span> <span class="n">transformed_graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_c</span> <span class="o">=</span> <span class="n">transformed_graph</span>

        <span class="n">instruments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="p">{</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">}:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nearest_separator</span><span class="p">(</span><span class="n">G_c</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
            <span class="c1"># Condition to check if W d-separates Y from Z</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">W</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">descendants</span><span class="p">(</span><span class="n">G_c</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">X</span> <span class="ow">in</span> <span class="n">W</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Condition to check if X d-connected to I after conditioning on W.</span>
            <span class="k">elif</span> <span class="n">X</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="n">Z</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">struct</span><span class="o">=</span><span class="n">G_c</span><span class="p">)[</span><span class="n">Z</span><span class="p">]:</span>
                <span class="n">instruments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Z</span><span class="p">,</span> <span class="n">W</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="n">instruments</span></div>

<div class="viewcode-block" id="SEMGraph.to_lisrel"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.to_lisrel">[docs]</a>    <span class="k">def</span> <span class="nf">to_lisrel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the model from a graphical representation to an equivalent algebraic</span>
<span class="sd">        representation. This converts the model into a Reticular Action Model (RAM) model</span>
<span class="sd">        representation which is implemented by `pgmpy.models.SEMAlg` class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SEMAlg instance: Instance of `SEMAlg` representing the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; sem = SEM.from_graph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                              (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                              (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                      latents=[],</span>
<span class="sd">        ...                      err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">        ...                      err_var={})</span>
<span class="sd">        &gt;&gt;&gt; sem.to_lisrel()</span>
<span class="sd">        # TODO: Complete this.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_standard_lisrel: Converts to the standard lisrel format and returns the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span>
        <span class="n">graph_adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">graph_fixed</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="n">err_adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">err_adj</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Variance exists for each error term.</span>
        <span class="n">err_fixed</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Add the variance of the error terms.</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">err_fixed</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">err_fixed</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">wedge_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">obs_var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="n">wedge_y</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">nodelist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obs_var</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="kn">from</span> <span class="nn">pgmpy.models</span> <span class="kn">import</span> <span class="n">SEMAlg</span>

        <span class="k">return</span> <span class="n">SEMAlg</span><span class="p">(</span>
            <span class="n">eta</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">graph_adj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">err_adj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">wedge_y</span><span class="o">=</span><span class="n">wedge_y</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">graph_fixed</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;zeta&quot;</span><span class="p">:</span> <span class="n">err_fixed</span><span class="o">.</span><span class="n">T</span><span class="p">},</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__standard_lisrel_masks</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">err_graph</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called by `get_fixed_masks` and `get_masks` methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight: None | &#39;weight&#39;</span>
<span class="sd">            If None: Returns a 1.0 for an edge in the graph else 0.0</span>
<span class="sd">            If &#39;weight&#39;: Returns the weight if a weight is assigned to an edge</span>
<span class="sd">                    else 0.0</span>

<span class="sd">        var: dict</span>
<span class="sd">            Dict with keys eta, xi, y, and x representing the variables in them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray: Adjacency matrix of model&#39;s graph structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        B: Effect matrix of eta on eta</span>
<span class="sd">        \gamma: Effect matrix of xi on eta</span>
<span class="sd">        \wedge_y: Effect matrix of eta on y</span>
<span class="sd">        \wedge_x: Effect matrix of xi on x</span>
<span class="sd">        \phi: Covariance matrix of xi</span>
<span class="sd">        \psi: Covariance matrix of eta errors</span>
<span class="sd">        \theta_e: Covariance matrix of y errors</span>
<span class="sd">        \theta_del: Covariance matrix of x errors</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Arrange the adjacency matrix in order y, x, eta, xi and then slice masks from it.</span>
        <span class="c1">#       y(p)   x(q)   eta(m)  xi(n)</span>
        <span class="c1"># y</span>
        <span class="c1"># x</span>
        <span class="c1"># eta \wedge_y          B</span>
        <span class="c1"># xi         \wedge_x \Gamma</span>
        <span class="c1">#</span>
        <span class="c1"># But here we are slicing from the transpose of adjacency because we want incoming</span>
        <span class="c1"># edges instead of outgoing because parameters come before variables in equations.</span>
        <span class="c1">#</span>
        <span class="c1">#       y(p)   x(q)   eta(m)  xi(n)</span>
        <span class="c1"># y                  \wedge_y</span>
        <span class="c1"># x                          \wedge_x</span>
        <span class="c1"># eta                   B    \Gamma</span>
        <span class="c1"># xi</span>
        <span class="n">y_vars</span><span class="p">,</span> <span class="n">x_vars</span><span class="p">,</span> <span class="n">eta_vars</span><span class="p">,</span> <span class="n">xi_vars</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]</span>

        <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">eta_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi_vars</span><span class="p">))</span>

        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">y_vars</span> <span class="o">+</span> <span class="n">x_vars</span> <span class="o">+</span> <span class="n">eta_vars</span> <span class="o">+</span> <span class="n">xi_vars</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">B_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">gamma_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>
        <span class="n">wedge_y_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">wedge_x_mask</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>

        <span class="n">err_nodelist</span> <span class="o">=</span> <span class="n">y_vars</span> <span class="o">+</span> <span class="n">x_vars</span> <span class="o">+</span> <span class="n">eta_vars</span> <span class="o">+</span> <span class="n">xi_vars</span>
        <span class="n">err_adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_matrix</span><span class="p">(</span>
            <span class="n">err_graph</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">err_nodelist</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">err_adj_matrix</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="n">theta_e_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[:</span><span class="n">p</span><span class="p">,</span> <span class="p">:</span><span class="n">p</span><span class="p">]</span>
        <span class="n">theta_del_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">]</span>
        <span class="n">psi_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="p">:</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">phi_mask</span> <span class="o">=</span> <span class="n">err_adj_matrix</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">+</span> <span class="n">m</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">B_mask</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma_mask</span><span class="p">,</span>
            <span class="s2">&quot;wedge_y&quot;</span><span class="p">:</span> <span class="n">wedge_y_mask</span><span class="p">,</span>
            <span class="s2">&quot;wedge_x&quot;</span><span class="p">:</span> <span class="n">wedge_x_mask</span><span class="p">,</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi_mask</span><span class="p">,</span>
            <span class="s2">&quot;theta_e&quot;</span><span class="p">:</span> <span class="n">theta_e_mask</span><span class="p">,</span>
            <span class="s2">&quot;theta_del&quot;</span><span class="p">:</span> <span class="n">theta_del_mask</span><span class="p">,</span>
            <span class="s2">&quot;psi&quot;</span><span class="p">:</span> <span class="n">psi_mask</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="SEMGraph.to_standard_lisrel"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMGraph.to_standard_lisrel">[docs]</a>    <span class="k">def</span> <span class="nf">to_standard_lisrel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the model to the standard LISREL representation of latent and measurement</span>
<span class="sd">        equations. The standard LISREL representation is given as:</span>

<span class="sd">        ..math::</span>
<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\Gamma \xi} + \mathbf{\zeta} \\</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{x} = \mathbf{\wedge_x \xi} + \mathbf{\delta} \\</span>
<span class="sd">            \mathbf{\Theta_e} = COV(\mathbf{\epsilon}) \\</span>
<span class="sd">            \mathbf{\Theta_\delta} = COV(\mathbf{\delta}) \\</span>
<span class="sd">            \mathbf{\Psi} = COV(\mathbf{\eta}) \\</span>
<span class="sd">            \mathbf{\Phi} = COV(\mathbf{\xi}) \\</span>

<span class="sd">        Since the standard LISREL representation has restrictions on the types of model,</span>
<span class="sd">        this method adds extra latent variables with fixed loadings of `1` to make the model</span>
<span class="sd">        consistent with the restrictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var_names: dict (keys: eta, xi, y, x)</span>
<span class="sd">            Returns the variable names in :math:`\mathbf{\eta}`, :math:`\mathbf{\xi}`,</span>
<span class="sd">            :math:`\mathbf{y}`, :math:`\mathbf{x}`.</span>

<span class="sd">        params: dict (keys: B, gamma, wedge_y, wedge_x, theta_e, theta_del, phi, psi)</span>
<span class="sd">            Returns a boolean matrix for each of the parameters. A 1 in the matrix</span>
<span class="sd">            represents that there is an edge in the model, 0 represents there is no edge.</span>

<span class="sd">        fixed_values: dict (keys: B, gamma, wedge_y, wedge_x, theta_e, theta_del, phi, psi)</span>
<span class="sd">            Returns a matrix for each of the parameters. A value in the matrix represents the</span>
<span class="sd">            set value for the parameter in the model else it is 0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_lisrel: Converts the model to `pgmpy.models.SEMAlg` instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        TODO: Finish this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lisrel_err_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lisrel_latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lisrel_observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Add new latent nodes to convert it to LISREL format.</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">):</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">u</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">):</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">u</span>
        <span class="n">lisrel_latents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">lisrel_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Get values of eta, xi, y, x</span>
        <span class="n">latent_struct</span> <span class="o">=</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">lisrel_latents</span><span class="p">)</span>
        <span class="n">latent_indegree</span> <span class="o">=</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span>

        <span class="n">eta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">latent_struct</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">latent_indegree</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">exo</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">exo</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lisrel_latents</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="n">eta</span><span class="p">:</span>
            <span class="n">y</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">endo</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lisrel_latents</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># If some node has edges from both eta and xi, replace it with another latent variable</span>
        <span class="c1"># otherwise it won&#39;t get included in any of the matrices.</span>
        <span class="c1"># TODO: Patchy work. Find a better solution.</span>
        <span class="n">common_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">common_elements</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">common_elements</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_l_&quot;</span> <span class="o">+</span> <span class="n">var</span>
            <span class="n">lisrel_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">lisrel_graph</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lisrel_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_elements</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">common_elements</span><span class="p">)</span>

        <span class="n">var_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eta&quot;</span><span class="p">:</span> <span class="n">eta</span><span class="p">,</span> <span class="s2">&quot;xi&quot;</span><span class="p">:</span> <span class="n">xi</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
        <span class="n">edges_masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_lisrel_masks</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">lisrel_graph</span><span class="p">,</span> <span class="n">err_graph</span><span class="o">=</span><span class="n">lisrel_err_graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var_names</span>
        <span class="p">)</span>
        <span class="n">fixed_masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__standard_lisrel_masks</span><span class="p">(</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">lisrel_graph</span><span class="p">,</span>
            <span class="n">err_graph</span><span class="o">=</span><span class="n">lisrel_err_graph</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="n">var</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">edges_masks</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SEMAlg"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg">[docs]</a><span class="k">class</span> <span class="nc">SEMAlg</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for algebraic representation of Structural Equation Models(SEMs). The model is</span>
<span class="sd">    represented using the Reticular Action Model (RAM).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wedge_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes SEMAlg model. The model is represented using the Reticular Action Model(RAM)</span>
<span class="sd">        which is given as:</span>
<span class="sd">        ..math::</span>
<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\zeta}</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta}</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of all the observed and latent variables in the</span>
<span class="sd">        model, :math:`\mathbf{y}` are the set of observed variables, :math:`\mathbf{\zeta}` is</span>
<span class="sd">        the error terms for :math:`\mathbf{\eta}`, and \mathbf{\wedge_y} is a boolean array to</span>
<span class="sd">        select the observed variables from :math:`\mathbf{\eta}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        The following set of parameters are used to set the learnable parameters in the model.</span>
<span class="sd">        To specify the values of the parameter use the `fixed_values` parameter. Either `eta`,</span>
<span class="sd">        `B`, `zeta`, and `wedge_y`, or `fixed_values` need to be specified.</span>

<span class="sd">        eta: list/array-like</span>
<span class="sd">            The name of the variables in the model.</span>

<span class="sd">        B: 2-D array (boolean)</span>
<span class="sd">            The learnable parameters in the `B` matrix.</span>

<span class="sd">        zeta: 2-D array (boolean)</span>
<span class="sd">            The learnable parameters in the covariance matrix of the error terms.</span>

<span class="sd">        wedge_y: 2-D array</span>
<span class="sd">            The `wedge_y` matrix.</span>

<span class="sd">        fixed_params: dict (default: None)</span>
<span class="sd">            A dict of fixed values for parameters.</span>

<span class="sd">            If None all the parameters specified by `B`, and `zeta` are learnable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEMAlg instance: An instance of the object with initalized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span> <span class="o">=</span> <span class="n">wedge_y</span>

        <span class="c1"># Get the observed variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="p">[</span><span class="n">row_i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fixed_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">fixed_values</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">fixed_values</span><span class="p">[</span><span class="s2">&quot;zeta&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Masks represent the parameters which need to be learnt while training.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SEMAlg.to_SEMGraph"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.to_SEMGraph">[docs]</a>    <span class="k">def</span> <span class="nf">to_SEMGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a graph structure from the LISREL representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEMGraph instance: A path model of the model.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        &gt;&gt;&gt; model = SEMAlg()</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">err_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)}</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">),</span>
            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])},</span>
        <span class="p">)</span>
        <span class="c1"># Fill zeta diagonal with 0&#39;s as they represent variance and would add self loops in the graph.</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="n">zeta</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">),</span>
            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])},</span>
        <span class="p">)</span>

        <span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pgmpy.models</span> <span class="kn">import</span> <span class="n">SEMGraph</span>

        <span class="c1"># TODO: Add edge weights</span>
        <span class="n">sem_graph</span> <span class="o">=</span> <span class="n">SEMGraph</span><span class="p">(</span>
            <span class="n">ebunch</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span>
            <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span>
            <span class="n">err_corr</span><span class="o">=</span><span class="n">err_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span>
            <span class="n">err_var</span><span class="o">=</span><span class="n">err_var</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sem_graph</span></div>

<div class="viewcode-block" id="SEMAlg.set_params"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.set_params">[docs]</a>    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">zeta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the fixed parameters of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B: 2D array</span>
<span class="sd">            The B matrix.</span>

<span class="sd">        zeta: 2D array</span>
<span class="sd">            The covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">=</span> <span class="n">zeta</span></div>

<div class="viewcode-block" id="SEMAlg.generate_samples"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEMAlg.generate_samples">[docs]</a>    <span class="k">def</span> <span class="nf">generate_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates random samples from the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_samples: int</span>
<span class="sd">            The number of samples to generate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame: The generated samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters for the model has not been specified.&quot;</span><span class="p">)</span>

        <span class="n">B_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_fixed_mask</span><span class="p">)</span>
        <span class="n">implied_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span> <span class="o">@</span> <span class="n">B_inv</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta_fixed_mask</span> <span class="o">@</span> <span class="n">B_inv</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>

        <span class="c1"># Check if implied covariance matrix is positive definite.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">implied_cov</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The implied covariance matrix is not positive definite.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Please check model parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get the order of observed variables</span>
        <span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wedge_y</span><span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y_index</span><span class="p">]</span>

        <span class="c1"># Generate samples and return a dataframe.</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
            <span class="n">mean</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">implied_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
            <span class="n">cov</span><span class="o">=</span><span class="n">implied_cov</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">observed</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SEM"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM">[docs]</a><span class="k">class</span> <span class="nc">SEM</span><span class="p">(</span><span class="n">SEMGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for representing Structural Equation Models. This class is a wrapper over</span>
<span class="sd">    `SEMGraph` and `SEMAlg` to provide a consistent API over the different representations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model: SEMGraph instance</span>
<span class="sd">        A graphical representation of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syntax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a `SEM` object. Preferred way to initialize the object is to use one of</span>
<span class="sd">        the `from_lavaan`, `from_graph`, `from_lisrel`, or `from_RAM` methods.</span>

<span class="sd">        There are three possible ways to initialize the model:</span>
<span class="sd">            1. Lavaan syntax: `lavaan_str` needs to be specified.</span>
<span class="sd">            2. Graph structure: `ebunch`, `latents`, `err_corr`, and `err_var` need to be specified.</span>
<span class="sd">            3. LISREL syntax: `var_names`, `params`, and `fixed_masks` need to be specified.</span>
<span class="sd">            4. Reticular Action Model (RAM/all-y) syntax: `var_names`, `B`, `zeta`, and `wedge_y`</span>
<span class="sd">                                                            need to be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        syntax: str (lavaan|graph|lisrel|ram)</span>
<span class="sd">            The syntax used to initialize the model.</span>

<span class="sd">        kwargs:</span>
<span class="sd">            For parameter details, check docstrings for `from_lavaan`, `from_graph`, `from_lisrel`,</span>
<span class="sd">            and `from_RAM` methods.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_lavaan: Initialize a model using lavaan syntax.</span>
<span class="sd">        from_graph: Initialize a model using graph structure.</span>
<span class="sd">        from_lisrel: Initialize a model using LISREL syntax.</span>
<span class="sd">        from_RAM: Initialize a model using Reticular Action Model(RAM/all-y) syntax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lavaan&quot;</span><span class="p">:</span>
            <span class="c1"># Create a SEMGraph model using the lavaan str.</span>

            <span class="c1"># Step 1: Define the grammar for each type of string.</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphanums</span><span class="p">)</span>
            <span class="n">reg_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;predictors&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;covariates&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">intercept_gram</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s2">&quot;inter_var&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;~&quot;</span> <span class="o">+</span> <span class="n">Word</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">covar_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">var</span><span class="p">(</span><span class="s2">&quot;covar_var1&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;~~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;covar_var2&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">latent_gram</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">var</span><span class="p">(</span><span class="s2">&quot;latent&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;=~&quot;</span>
                <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Step 2: Preprocess string to lines</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lavaan_str&quot;</span><span class="p">]</span>

            <span class="c1"># Step 3: Initialize arguments and fill them by parsing each line.</span>
            <span class="n">ebunch</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">latents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">err_corr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">err_var</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">intercept_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">reg_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">reg_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;predictors&quot;</span><span class="p">]:</span>
                            <span class="n">ebunch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="p">(</span><span class="n">covariate</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">covariate</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;covariates&quot;</span><span class="p">]</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">covar_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">covar_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;covar_var2&quot;</span><span class="p">]:</span>
                            <span class="n">err_corr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;covar_var1&quot;</span><span class="p">],</span> <span class="n">var</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">latent_gram</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">latent_gram</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">latents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;latent&quot;</span><span class="p">])</span>
                        <span class="n">ebunch</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">[(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;latent&quot;</span><span class="p">],</span> <span class="n">obs</span><span class="p">)</span> <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">]]</span>
                        <span class="p">)</span>

            <span class="c1"># Step 4: Call the parent __init__ with the arguments</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="n">ebunch</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span> <span class="n">err_corr</span><span class="o">=</span><span class="n">err_corr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;graph&quot;</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">ebunch</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ebunch&quot;</span><span class="p">],</span>
                <span class="n">latents</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;latents&quot;</span><span class="p">],</span>
                <span class="n">err_corr</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;err_corr&quot;</span><span class="p">],</span>
                <span class="n">err_var</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;err_var&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lisrel&quot;</span><span class="p">:</span>

            <span class="n">model</span> <span class="o">=</span> <span class="n">SEMAlg</span><span class="p">(</span>
                <span class="n">var_names</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="o">=</span><span class="n">fixed_masks</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to_SEMGraph</span><span class="p">()</span>
            <span class="c1"># Initialize an empty SEMGraph instance and set the properties.</span>
            <span class="c1"># TODO: Boilerplate code, find a better way to do this.</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">latents</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obseved</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">observed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err_graph</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">err_graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_graph_struct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">full_graph_struct</span>

        <span class="k">elif</span> <span class="n">syntax</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ram&quot;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">SEMAlg</span><span class="p">(</span>
                <span class="n">eta</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;var_names&quot;</span><span class="p">],</span>
                <span class="n">B</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span>
                <span class="n">zeta</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;zeta&quot;</span><span class="p">],</span>
                <span class="n">wedge_y</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span>
                <span class="n">fixed_values</span><span class="o">=</span><span class="n">fixed_masks</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SEM.from_lavaan"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_lavaan">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_lavaan</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using lavaan syntax.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string: str (default: None)</span>
<span class="sd">            A `lavaan` style multiline set of regression equation representing the model.</span>
<span class="sd">            Refer http://lavaan.ugent.be/tutorial/syntax1.html for details.</span>

<span class="sd">        filename: str (default: None)</span>
<span class="sd">            The filename of the file containing the model in lavaan syntax.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">lavaan_str</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string</span><span class="p">:</span>
            <span class="n">lavaan_str</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either `filename` or `string` need to be specified&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;lavaan&quot;</span><span class="p">,</span> <span class="n">lavaan_str</span><span class="o">=</span><span class="n">lavaan_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="SEM.from_graph"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_graph">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_graph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ebunch</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_corr</span><span class="o">=</span><span class="p">[],</span> <span class="n">err_var</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using graphical structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebunch: list/array-like</span>
<span class="sd">            List of edges in form of tuples. Each tuple can be of two possible shape:</span>
<span class="sd">                1. (u, v): This would add an edge from u to v without setting any parameter</span>
<span class="sd">                           for the edge.</span>
<span class="sd">                2. (u, v, parameter): This would add an edge from u to v and set the edge&#39;s</span>
<span class="sd">                            parameter to `parameter`.</span>

<span class="sd">        latents: list/array-like</span>
<span class="sd">            List of nodes which are latent. All other variables are considered observed.</span>

<span class="sd">        err_corr: list/array-like</span>
<span class="sd">            List of tuples representing edges between error terms. It can be of the following forms:</span>
<span class="sd">                1. (u, v): Add correlation between error terms of `u` and `v`. Doesn&#39;t set any variance or</span>
<span class="sd">                           covariance values.</span>
<span class="sd">                2. (u, v, covar): Adds correlation between the error terms of `u` and `v` and sets the</span>
<span class="sd">                                  parameter to `covar`.</span>

<span class="sd">        err_var: dict</span>
<span class="sd">            Dict of the form (var: variance).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Defining a model (Union sentiment model[1]) without setting any paramaters.</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; sem = SEM.from_graph(ebunch=[(&#39;deferenc&#39;, &#39;unionsen&#39;), (&#39;laboract&#39;, &#39;unionsen&#39;),</span>
<span class="sd">        ...                              (&#39;yrsmill&#39;, &#39;unionsen&#39;), (&#39;age&#39;, &#39;deferenc&#39;),</span>
<span class="sd">        ...                              (&#39;age&#39;, &#39;laboract&#39;), (&#39;deferenc&#39;, &#39;laboract&#39;)],</span>
<span class="sd">        ...                      latents=[],</span>
<span class="sd">        ...                      err_corr=[(&#39;yrsmill&#39;, &#39;age&#39;)],</span>
<span class="sd">        ...                      err_var={})</span>

<span class="sd">        Defining a model (Education [2]) with all the parameters set. For not setting any</span>
<span class="sd">        parameter `np.NaN` can be explicitly passed.</span>
<span class="sd">        &gt;&gt;&gt; sem_edu = SEM.from_graph(ebunch=[(&#39;intelligence&#39;, &#39;academic&#39;, 0.8), (&#39;intelligence&#39;, &#39;scale_1&#39;, 0.7),</span>
<span class="sd">        ...                                  (&#39;intelligence&#39;, &#39;scale_2&#39;, 0.64), (&#39;intelligence&#39;, &#39;scale_3&#39;, 0.73),</span>
<span class="sd">        ...                                  (&#39;intelligence&#39;, &#39;scale_4&#39;, 0.82), (&#39;academic&#39;, &#39;SAT_score&#39;, 0.98),</span>
<span class="sd">        ...                                  (&#39;academic&#39;, &#39;High_school_gpa&#39;, 0.75), (&#39;academic&#39;, &#39;ACT_score&#39;, 0.87)],</span>
<span class="sd">        ...                          latents=[&#39;intelligence&#39;, &#39;academic&#39;],</span>
<span class="sd">        ...                          err_corr=[],</span>
<span class="sd">        ...                          err_var={})</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] McDonald, A, J., &amp; Clelland, D. A. (1984). Textile Workers and Union Sentiment.</span>
<span class="sd">            Social Forces, 63(2), 502â€“521</span>
<span class="sd">        [2] https://en.wikipedia.org/wiki/Structural_equation_modeling#/</span>
<span class="sd">            media/File:Example_Structural_equation_model.svg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span>
            <span class="n">ebunch</span><span class="o">=</span><span class="n">ebunch</span><span class="p">,</span>
            <span class="n">latents</span><span class="o">=</span><span class="n">latents</span><span class="p">,</span>
            <span class="n">err_corr</span><span class="o">=</span><span class="n">err_corr</span><span class="p">,</span>
            <span class="n">err_var</span><span class="o">=</span><span class="n">err_var</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SEM.from_lisrel"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_lisrel">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_lisrel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fixed_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using LISREL notation. The LISREL notation is defined as:</span>
<span class="sd">        ..math::</span>

<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\Gamma \xi} + mathbf{\zeta} \\</span>
<span class="sd">            \mathbf{y} = \mathbf{\wedge_y \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{x} = \mathbf{\wedge_x \xi} + \mathbf{\delta}</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of endogenous variables, :math:`\mathbf{\xi}`</span>
<span class="sd">        is the set of exogeneous variables, :math:`\mathbf{y}` and :math:`\mathbf{x}` are the</span>
<span class="sd">        set of measurement variables for :math:`\mathbf{\eta}` and :math:`\mathbf{\xi}`</span>
<span class="sd">        respectively. :math:`\mathbf{\zeta}`, :math:`\mathbf{\epsilon}`, and :math:`\mathbf{\delta}`</span>
<span class="sd">        are the error terms for :math:`\mathbf{\eta}`, :math:`\mathbf{y}`, and :math:`\mathbf{x}`</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        str_model: str (default: None)</span>
<span class="sd">            A `lavaan` style multiline set of regression equation representing the model.</span>
<span class="sd">            Refer http://lavaan.ugent.be/tutorial/syntax1.html for details.</span>

<span class="sd">            If None requires `var_names` and `params` to be specified.</span>

<span class="sd">        var_names: dict (default: None)</span>
<span class="sd">            A dict with the keys: eta, xi, y, and x. Each keys should have a list as the value</span>
<span class="sd">            with the name of variables.</span>

<span class="sd">        params: dict (default: None)</span>
<span class="sd">            A dict of LISREL representation non-zero parameters. Must contain the following</span>
<span class="sd">            keys: B, gamma, wedge_y, wedge_x, phi, theta_e, theta_del, and psi.</span>

<span class="sd">            If None `str_model` must be specified.</span>

<span class="sd">        fixed_params: dict (default: None)</span>
<span class="sd">            A dict of fixed values for parameters. The shape of the parameters should be same</span>
<span class="sd">            as params.</span>

<span class="sd">            If None all the parameters are learnable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEM instance: An instance of the object with initalized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEMAlg</span>
<span class="sd">        # TODO: Finish this example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;eta&quot;</span><span class="p">]),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;xi&quot;</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;wedge_x&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta_e&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;theta_del&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;psi&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;wedge_y&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;wedge_x&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;theta_e&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;theta_del&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;psi&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span> <span class="n">fixed_params</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">]],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_RAM</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="s2">&quot;zeta&quot;</span><span class="p">:</span> <span class="n">zeta</span><span class="p">},</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SEM.from_RAM"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.from_RAM">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_RAM</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wedge_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `SEM` instance using Reticular Action Model(RAM) notation. The model</span>
<span class="sd">        is defined as:</span>

<span class="sd">        ..math::</span>

<span class="sd">            \mathbf{\eta} = \mathbf{B \eta} + \mathbf{\epsilon} \\</span>
<span class="sd">            \mathbf{\y} = \wedge_y \mathbf{\eta}</span>
<span class="sd">            \zeta = COV(\mathbf{\epsilon})</span>

<span class="sd">        where :math:`\mathbf{\eta}` is the set of variables (both latent and observed),</span>
<span class="sd">        :math:`\mathbf{\epsilon}` are the error terms, :math:`\mathbf{y}` is the set</span>
<span class="sd">        of observed variables, :math:`\wedge_y` is a boolean array of the shape (no of</span>
<span class="sd">        observed variables, no of total variables).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: list, array-like</span>
<span class="sd">            List of variables (both latent and observed) in the model.</span>

<span class="sd">        B: 2-D boolean array (shape: `len(variables)` x `len(variables)`)</span>
<span class="sd">            The non-zero parameters in :math:`B` matrix. Refer model definition in docstring for details.</span>

<span class="sd">        zeta: 2-D boolean array (shape: `len(variables)` x `len(variables)`)</span>
<span class="sd">            The non-zero parameters in :math:`\zeta` (error covariance) matrix. Refer model definition</span>
<span class="sd">            in docstring for details.</span>

<span class="sd">        observed: list, array-like (optional: Either `observed` or `wedge_y` needs to be specified)</span>
<span class="sd">            List of observed variables in the model.</span>

<span class="sd">        wedge_y: 2-D array (shape: no. observed x total vars) (optional: Either `observed` or `wedge_y`)</span>
<span class="sd">            The :math:`\wedge_y` matrix. Refer model definition in docstring for details.</span>

<span class="sd">        fixed_values: dict (optional)</span>
<span class="sd">            If specified, fixes the parameter values and are not changed during estimation.</span>
<span class="sd">            A dict with the keys B, zeta.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pgmpy.models.SEM instance: An instance of the object with initialized values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import SEM</span>
<span class="sd">        &gt;&gt;&gt; SEM.from_RAM  # TODO: Finish this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
            <span class="n">wedge_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)))</span>
            <span class="n">obs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observed</span><span class="p">)}</span>
            <span class="n">all_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variables</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
                <span class="n">wedge_y</span><span class="p">[</span><span class="n">obs_dict</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">all_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">syntax</span><span class="o">=</span><span class="s2">&quot;ram&quot;</span><span class="p">,</span>
            <span class="n">var_names</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
            <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span>
            <span class="n">wedge_y</span><span class="o">=</span><span class="n">wedge_y</span><span class="p">,</span>
            <span class="n">fixed_values</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SEM.fit"><a class="viewcode-back" href="../../../models/sem.html#pgmpy.models.SEM.SEM.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Ankur Ankan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-177825880-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-177825880-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pgmpy.base.DAG &mdash; pgmpy 0.1.15 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> pgmpy
          

          
          </a>

          
            
            
              <div class="version">
                dev branch
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../started/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/contributing.html">Contributing to pgmpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../started/license.html">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Base Structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html">Directed Acyclic Graph (DAG)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html#module-pgmpy.base.DAG.PDAG">Partial Directed Acyclic Graph (PDAG)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/bayesiannetwork.html">Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/dbn.html">Dynamic Bayesian Network (DBN)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/sem.html">Structural Equation Models (SEM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/naive.html">Naive Bayes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/noisyor.html">NoisyOr Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/markovnetwork.html">Markov Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/junctiontree.html">Junction Tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/clustergraph.html">Cluster Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/factorgraph.html">Factor Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/markovchain.html">Markov Chain</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parameterization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/discrete.html">Discrete</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/continuous.html">Continuous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/discretize.html">Discretizing Methods</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact Inference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/ve.html">Variable Elimination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/ve.html#module-pgmpy.inference.EliminationOrder">Elimination Ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/bp.html">Belief Propagation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/causal.html">Causal Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/mplp.html">MPLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/dbn_infer.html">Dynamic Bayesian Network Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/model_testing.html">Model Testing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Approximate Inference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/approx_infer.html">Approximate Inference Using Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/bn_sampling.html">Bayesian Model Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/gibbs.html">Gibbs Sampling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parameter Estimation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/mle.html">Maximum Likelihood Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/bayesian_est.html">Bayesian Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/em.html">Expectation Maximization (EM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/sem_estimator.html">Structural Equation Model Estimators</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Structure Learning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/pc.html">PC (Constraint-Based Estimator)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/pc.html#module-pgmpy.estimators.CITests">Conditional Independence Tests for PC algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/hill.html">Hill Climb Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/hill.html#structure-score">Structure Score</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/tree.html">Tree Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/mmhc.html">Mmhc Estimator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/exhaustive.html">Exhaustive Search</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Model Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../metrics/metrics.html">Metrics for testing models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/bif.html">BIF (Bayesian Interchange Format)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/uai.html">UAI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/xmlbif.html">XMLBIF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/pomdpx.html">PomdpX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/xmlbelief.html">XMLBeliefNetwork</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Earthquake.html">1. Example Using the Earthquake network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Monty%20Hall%20Problem.html">2. Monty Hall Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Creating%20a%20Discrete%20Bayesian%20Network.html">3. Creating discrete Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Inference%20in%20Discrete%20Bayesian%20Networks.html">4. Inference in Discrete Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Causal%20Games.html">5. Causal Games</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Causal%20Inference.html">6. Causal Inference Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Learning%20Parameters%20in%20Discrete%20Bayesian%20Networks.html">7. Parameter Learning in Discrete Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20in%20Bayesian%20Networks.html">8. Structure Learning in Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20with%20Chow-Liu.html">9. Learning Tree Structure from Data using the Chow-Liu Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Structure%20Learning%20with%20TAN.html">10. Learning Tree-augmented Naive Bayes (TAN) Structure from Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Simulating%20Data.html">11. Normal Bayesian Network (no time variation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/Extending%20pgmpy.html">12. Extending pgmpy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/1.%20Introduction%20to%20Probabilistic%20Graphical%20Models.html">1. Introduction to Probabilitic Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/2.%20Bayesian%20Networks.html">2. Bayesian Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/3.%20Causal%20Bayesian%20Networks.html">3. Causal Bayesian Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/4.%20Markov%20Models.html">4. Markov Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/5.%20Exact%20Inference%20in%20Graphical%20Models.html">5. Exact Inference in Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/6.%20Approximate%20Inference%20in%20Graphical%20Models.html">6. Approximate Inference in Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/7.%20Parameterizing%20with%20Continuous%20Variables.html">7. Parameterizing with Continuous Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/8.%20Sampling%20Algorithms.html">8. Sampling In Continuous Graphical Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/9.%20Reading%20and%20Writing%20from%20pgmpy%20file%20formats.html">9. Reading and Writing from pgmpy file formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/10.%20Learning%20Bayesian%20Networks%20from%20Data.html">10. Learning Bayesian Networks from Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../detailed_notebooks/11.%20A%20Bayesian%20Network%20to%20model%20the%20influence%20of%20energy%20consumption%20on%20greenhouse%20gases%20in%20Italy.html">11. A Bayesian Network to model the influence of energy consumption on greenhouse gases in Italy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pgmpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pgmpy.base.DAG</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pgmpy.base.DAG</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pgmpy.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="kn">from</span> <span class="nn">pgmpy.independencies</span> <span class="kn">import</span> <span class="n">Independencies</span>


<div class="viewcode-block" id="DAG"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG">[docs]</a><span class="k">class</span> <span class="nc">DAG</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all Directed Graphical Models.</span>

<span class="sd">    Each node in the graph can represent either a random variable, `Factor`,</span>
<span class="sd">    or a cluster of random variables. Edges in the graph represent the</span>
<span class="sd">    dependencies between these.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: input graph</span>
<span class="sd">        Data to initialize graph. If data=None (default) an empty graph is</span>
<span class="sd">        created. The data can be an edge list or any Networkx graph object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an empty DAG with no nodes and no edges</span>

<span class="sd">    &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">    &gt;&gt;&gt; G = DAG()</span>

<span class="sd">    G can be grown in several ways:</span>

<span class="sd">    **Nodes:**</span>

<span class="sd">    Add one node at a time:</span>

<span class="sd">    &gt;&gt;&gt; G.add_node(node=&#39;a&#39;)</span>

<span class="sd">    Add the nodes from any container (a list, set or tuple or the nodes</span>
<span class="sd">    from another graph).</span>

<span class="sd">    &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;a&#39;, &#39;b&#39;])</span>

<span class="sd">    **Edges:**</span>

<span class="sd">    G can also be grown by adding edges.</span>

<span class="sd">    Add one edge,</span>

<span class="sd">    &gt;&gt;&gt; G.add_edge(u=&#39;a&#39;, v=&#39;b&#39;)</span>

<span class="sd">    a list of edges,</span>

<span class="sd">    &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)])</span>

<span class="sd">    If some edges connect nodes not yet in the model, the nodes</span>
<span class="sd">    are added automatically. There are no errors when adding</span>
<span class="sd">    nodes or edges that already exist.</span>

<span class="sd">    **Shortcuts:**</span>

<span class="sd">    Many common graph features allow python syntax for speed reporting.</span>

<span class="sd">    &gt;&gt;&gt; &#39;a&#39; in G     # check if node in graph</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; len(G)  # number of nodes in graph</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXNoCycle</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;Cycles are not allowed in a DAG.&quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges indicating the path taken for a loop: &quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">) &quot;</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.add_node"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single node to the Graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: str, int, or any hashable python object.</span>
<span class="sd">            The node to add to the graph.</span>

<span class="sd">        weight: int, float</span>
<span class="sd">            The weight of the node.</span>

<span class="sd">        latent: boolean (default: False)</span>
<span class="sd">            Specifies whether the variable is latent or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(node=&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted(G.nodes())</span>
<span class="sd">        [&#39;A&#39;]</span>

<span class="sd">        Adding a node with some weight.</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(node=&#39;B&#39;, weight=0.3)</span>

<span class="sd">        The weight of these nodes can be accessed as:</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;B&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;A&#39;]</span>
<span class="sd">        {&#39;weight&#39;: None}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for networkx 2.0 syntax</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">attrs</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">latent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.add_nodes_from"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.add_nodes_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add multiple nodes to the Graph.</span>

<span class="sd">        **The behviour of adding weights is different than in networkx.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes: iterable container</span>
<span class="sd">            A container of nodes (list, dict, set, or any hashable python</span>
<span class="sd">            object).</span>

<span class="sd">        weights: list, tuple (default=None)</span>
<span class="sd">            A container of weights (int, float). The weight value at index i</span>
<span class="sd">            is associated with the variable at index i.</span>

<span class="sd">        latent: list, tuple (default=False)</span>
<span class="sd">            A container of boolean. The value at index i tells whether the</span>
<span class="sd">            node at index i is latent or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))</span>

<span class="sd">        Adding nodes with weights:</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;D&#39;, &#39;E&#39;], weights=[0.3, 0.6])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;D&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;E&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.6}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;A&#39;]</span>
<span class="sd">        {&#39;weight&#39;: None}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latent</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">latent</span> <span class="o">=</span> <span class="p">[</span><span class="n">latent</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of elements in nodes and weights&quot;</span> <span class="s2">&quot;should be equal.&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">latent</span><span class="o">=</span><span class="n">latent</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">latent</span><span class="o">=</span><span class="n">latent</span><span class="p">[</span><span class="n">index</span><span class="p">])</span></div>

<div class="viewcode-block" id="DAG.add_edge"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge between u and v.</span>

<span class="sd">        The nodes u and v will be automatically added if they are</span>
<span class="sd">        not already in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u, v : nodes</span>
<span class="sd">            Nodes can be any hashable Python object.</span>

<span class="sd">        weight: int, float (default=None)</span>
<span class="sd">            The weight of the edge</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(u=&#39;Alice&#39;, v=&#39;Bob&#39;)</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>

<span class="sd">        When the node is not already present in the graph:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(u=&#39;Alice&#39;, v=&#39;Ankur&#39;)</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Ankur&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>

<span class="sd">        Adding edges with weight:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(&#39;Ankur&#39;, &#39;Maria&#39;, weight=0.1)</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Ankur&#39;][&#39;Maria&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.add_edges_from"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.add_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all the edges in ebunch.</span>

<span class="sd">        If nodes referred in the ebunch are not already present, they</span>
<span class="sd">        will be automatically added. Node names can be any hashable python</span>
<span class="sd">        object.</span>

<span class="sd">        **The behavior of adding weights is different than networkx.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebunch : container of edges</span>
<span class="sd">            Each edge given in the container will be added to the graph.</span>
<span class="sd">            The edges must be given as 2-tuples (u, v).</span>

<span class="sd">        weights: list, tuple (default=None)</span>
<span class="sd">            A container of weights (int, float). The weight value at index i</span>
<span class="sd">            is associated with the edge at index i.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>

<span class="sd">        When the node is not already in the model:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;, &#39;Ankur&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>

<span class="sd">        Adding edges with weights:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;Ankur&#39;, &#39;Maria&#39;), (&#39;Maria&#39;, &#39;Mason&#39;)],</span>
<span class="sd">        ...                  weights=[0.3, 0.5])</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Ankur&#39;][&#39;Maria&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Maria&#39;][&#39;Mason&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.5}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ebunch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of elements in ebunch and weights&quot;</span> <span class="s2">&quot;should be equal&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ebunch</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ebunch</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">ebunch</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="DAG.get_parents"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_parents">[docs]</a>    <span class="k">def</span> <span class="nf">get_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of parents of node.</span>

<span class="sd">        Throws an error if the node is not present in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">            The node whose parents would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG(ebunch=[(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.get_parents(node=&#39;grade&#39;)</span>
<span class="sd">        [&#39;diff&#39;, &#39;intel&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.moralize"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.moralize">[docs]</a>    <span class="k">def</span> <span class="nf">moralize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all the immoralities in the DAG and creates a moral</span>
<span class="sd">        graph (UndirectedGraph).</span>

<span class="sd">        A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge</span>
<span class="sd">        between X and Y.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG(ebunch=[(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; moral_graph = G.moralize()</span>
<span class="sd">        &gt;&gt;&gt; moral_graph.edges()</span>
<span class="sd">        EdgeView([(&#39;intel&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;diff&#39;), (&#39;grade&#39;, &#39;diff&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moral_graph</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
        <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">moral_graph</span></div>

<div class="viewcode-block" id="DAG.get_leaves"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of leaves of the graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; graph.get_leaves()</span>
<span class="sd">        [&#39;C&#39;, &#39;D&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">out_degree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_degree_iter</span><span class="p">()</span> <span class="k">if</span> <span class="n">out_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="DAG.out_degree_iter"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.out_degree_iter">[docs]</a>    <span class="k">def</span> <span class="nf">out_degree_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">out_degree_iter</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.in_degree_iter"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.in_degree_iter">[docs]</a>    <span class="k">def</span> <span class="nf">in_degree_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">in_degree_iter</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.get_roots"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_roots">[docs]</a>    <span class="k">def</span> <span class="nf">get_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of roots of the graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;E&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; graph.get_roots()</span>
<span class="sd">        [&#39;A&#39;, &#39;E&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">())</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="DAG.get_children"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_children">[docs]</a>    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of children of node.</span>
<span class="sd">        Throws an error if the node is not present in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">            The node whose children would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; g = DAG(ebunch=[(&#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;D&#39;),</span>
<span class="sd">                                      (&#39;B&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;G&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; g.get_children(node=&#39;B&#39;)</span>
<span class="sd">        [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.get_independencies"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_independencies">[docs]</a>    <span class="k">def</span> <span class="nf">get_independencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes independencies in the DAG, by checking d-seperation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latex: boolean</span>
<span class="sd">            If latex=True then latex string of the independence assertion</span>
<span class="sd">            would be created.</span>

<span class="sd">        include_latents: boolean</span>
<span class="sd">            If True, includes latent variables in the independencies. Otherwise,</span>
<span class="sd">            only generates independencies on observed variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; chain = DAG([(&#39;X&#39;, &#39;Y&#39;), (&#39;Y&#39;, &#39;Z&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; chain.get_independencies()</span>
<span class="sd">        (X \u27C2 Z | Y)</span>
<span class="sd">        (Z \u27C2 X | Y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_latents</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="n">independencies</span> <span class="o">=</span> <span class="n">Independencies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_latents</span><span class="p">:</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="n">start</span><span class="p">}</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="n">start</span><span class="p">}</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">observed</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
                    <span class="n">d_seperated_variables</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">rest</span>
                        <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>
                        <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
                                <span class="n">start</span><span class="p">,</span>
                                <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
                                <span class="n">include_latents</span><span class="o">=</span><span class="n">include_latents</span><span class="p">,</span>
                            <span class="p">)[</span><span class="n">start</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">d_seperated_variables</span><span class="p">:</span>
                        <span class="n">independencies</span><span class="o">.</span><span class="n">add_assertions</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">d_seperated_variables</span><span class="p">,</span> <span class="n">observed</span><span class="p">]</span>
                        <span class="p">)</span>
        <span class="n">independencies</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">latex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">independencies</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">independencies</span><span class="o">.</span><span class="n">latex_string</span><span class="p">()</span></div>

<div class="viewcode-block" id="DAG.local_independencies"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.local_independencies">[docs]</a>    <span class="k">def</span> <span class="nf">local_independencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of Independencies containing the local independencies</span>
<span class="sd">        of each of the variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            variables whose local independencies are to be found.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                         (&#39;grade&#39;, &#39;letter&#39;), (&#39;intel&#39;, &#39;SAT&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; ind = student.local_independencies(&#39;grade&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ind</span>
<span class="sd">        (grade \u27C2 SAT | diff, intel)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">independencies</span> <span class="o">=</span> <span class="n">Independencies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">non_descendents</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
                <span class="o">-</span> <span class="p">{</span><span class="n">variable</span><span class="p">}</span>
                <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">non_descendents</span> <span class="o">-</span> <span class="n">parents</span><span class="p">:</span>
                <span class="n">independencies</span><span class="o">.</span><span class="n">add_assertions</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">non_descendents</span> <span class="o">-</span> <span class="n">parents</span><span class="p">,</span> <span class="n">parents</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">independencies</span></div>

<div class="viewcode-block" id="DAG.is_iequivalent"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.is_iequivalent">[docs]</a>    <span class="k">def</span> <span class="nf">is_iequivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the given model is I-equivalent</span>

<span class="sd">        Two graphs G1 and G2 are said to be I-equivalent if they have same skeleton</span>
<span class="sd">        and have same set of immoralities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : A DAG object, for which you want to check I-equivalence</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        I-equivalence: boolean</span>
<span class="sd">            True if both are I-equivalent, False otherwise</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;V&#39;, &#39;W&#39;), (&#39;W&#39;, &#39;X&#39;),</span>
<span class="sd">        ...                   (&#39;X&#39;, &#39;Y&#39;), (&#39;Z&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G1 = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G1.add_edges_from([(&#39;W&#39;, &#39;V&#39;), (&#39;X&#39;, &#39;W&#39;),</span>
<span class="sd">        ...                    (&#39;X&#39;, &#39;Y&#39;), (&#39;Z&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.is_iequivalent(G1)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Model must be an instance of DAG. Got type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="DAG.get_immoralities"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_immoralities">[docs]</a>    <span class="k">def</span> <span class="nf">get_immoralities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the immoralities in the model</span>
<span class="sd">        A v-structure X -&gt; Z &lt;- Y is an immorality if there is no direct edge between X and Y .</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Immoralities: set</span>
<span class="sd">            A set of all the immoralities in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;),</span>
<span class="sd">        ...                         (&#39;intel&#39;, &#39;SAT&#39;), (&#39;grade&#39;, &#39;letter&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.get_immoralities()</span>
<span class="sd">        {(&#39;diff&#39;, &#39;intel&#39;)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">immoralities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">parents</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span>
                    <span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">immoralities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">parents</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">immoralities</span></div>

<div class="viewcode-block" id="DAG.is_dconnected"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.is_dconnected">[docs]</a>    <span class="k">def</span> <span class="nf">is_dconnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if there is an active trail (i.e. d-connection) between</span>
<span class="sd">        `start` and `end` node given that `observed` is observed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int, str, any hashable python object.</span>
<span class="sd">            The nodes in the DAG between which to check the d-connection/active trail.</span>

<span class="sd">        observed : list, array-like (optional)</span>
<span class="sd">            If given the active trail would be computed assuming these nodes to</span>
<span class="sd">            be observed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_nodes_from([&#39;diff&#39;, &#39;intel&#39;, &#39;grades&#39;, &#39;letter&#39;, &#39;sat&#39;])</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grades&#39;), (&#39;intel&#39;, &#39;grades&#39;), (&#39;grades&#39;, &#39;letter&#39;),</span>
<span class="sd">        ...                         (&#39;intel&#39;, &#39;sat&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.is_dconnected(&#39;diff&#39;, &#39;intel&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; student.is_dconnected(&#39;grades&#39;, &#39;sat&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">observed</span><span class="p">)[</span><span class="n">start</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="DAG.minimal_dseparator"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.minimal_dseparator">[docs]</a>    <span class="k">def</span> <span class="nf">minimal_dseparator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the minimal d-separating set for `start` and `end`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: node</span>
<span class="sd">            The first node.</span>

<span class="sd">        end: node</span>
<span class="sd">            The second node.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; dag.minimal_dseparator(start=&#39;A&#39;, end=&#39;C&#39;)</span>
<span class="sd">        {&#39;B&#39;}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] Algorithm 4, Page 10: Tian, Jin, Azaria Paz, and Judea Pearl. Finding minimal d-separators. Computer Science Department, University of California, 1998.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">end</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No possible separators because start and end are adjacent&quot;</span>
            <span class="p">)</span>
        <span class="n">an_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ancestral_graph</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># If any of the parents were latents, take the latent&#39;s parent</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">separator</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">separator_copy</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">separator</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
                    <span class="n">separator_copy</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">separator_copy</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
            <span class="n">separator</span> <span class="o">=</span> <span class="n">separator_copy</span>
        <span class="c1"># Remove the start and end nodes in case it reaches there while removing latents.</span>
        <span class="n">separator</span><span class="o">.</span><span class="n">difference_update</span><span class="p">({</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">})</span>

        <span class="c1"># If the initial set is not able to d-separate, no d-separator is possible.</span>
        <span class="k">if</span> <span class="n">an_graph</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">separator</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Go through the separator set, remove one element and check if it remains</span>
        <span class="c1"># a dseparating set.</span>
        <span class="n">minimal_separator</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">separator</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">an_graph</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">minimal_separator</span> <span class="o">-</span> <span class="p">{</span><span class="n">u</span><span class="p">}):</span>
                <span class="n">minimal_separator</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">minimal_separator</span></div>

<div class="viewcode-block" id="DAG.get_markov_blanket"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_markov_blanket">[docs]</a>    <span class="k">def</span> <span class="nf">get_markov_blanket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a markov blanket for a random variable. In the case</span>
<span class="sd">        of Bayesian Networks, the markov blanket is the set of</span>
<span class="sd">        node&#39;s parents, its children and its children&#39;s other parents.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Markov Blanket: list</span>
<span class="sd">            List of nodes in the markov blanket of `node`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">              The node whose markov blanket would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.factors.discrete import TabularCPD</span>
<span class="sd">        &gt;&gt;&gt; G = DAG([(&#39;x&#39;, &#39;y&#39;), (&#39;z&#39;, &#39;y&#39;), (&#39;y&#39;, &#39;w&#39;), (&#39;y&#39;, &#39;v&#39;), (&#39;u&#39;, &#39;w&#39;),</span>
<span class="sd">                               (&#39;s&#39;, &#39;v&#39;), (&#39;w&#39;, &#39;t&#39;), (&#39;w&#39;, &#39;m&#39;), (&#39;v&#39;, &#39;n&#39;), (&#39;v&#39;, &#39;q&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.get_markov_blanket(&#39;y&#39;)</span>
<span class="sd">        [&#39;s&#39;, &#39;w&#39;, &#39;x&#39;, &#39;u&#39;, &#39;z&#39;, &#39;v&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">blanket_nodes</span> <span class="o">=</span> <span class="n">children</span> <span class="o">+</span> <span class="n">parents</span>
        <span class="k">for</span> <span class="n">child_node</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">blanket_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">child_node</span><span class="p">))</span>
        <span class="n">blanket_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">blanket_nodes</span><span class="p">)</span>
        <span class="n">blanket_nodes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">blanket_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.active_trail_nodes"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.active_trail_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">active_trail_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the given variables as keys and all the nodes reachable</span>
<span class="sd">        from that respective variable as values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            variables whose active trails are to be found.</span>

<span class="sd">        observed : List of nodes (optional)</span>
<span class="sd">            If given the active trails would be computed assuming these nodes to be</span>
<span class="sd">            observed.</span>

<span class="sd">        include_latents: boolean (default: False)</span>
<span class="sd">            Whether to include the latent variables in the returned active trail nodes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_nodes_from([&#39;diff&#39;, &#39;intel&#39;, &#39;grades&#39;])</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grades&#39;), (&#39;intel&#39;, &#39;grades&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.active_trail_nodes(&#39;diff&#39;)</span>
<span class="sd">        {&#39;diff&#39;: {&#39;diff&#39;, &#39;grades&#39;}}</span>
<span class="sd">        &gt;&gt;&gt; student.active_trail_nodes([&#39;diff&#39;, &#39;intel&#39;], observed=&#39;grades&#39;)</span>
<span class="sd">        {&#39;diff&#39;: {&#39;diff&#39;, &#39;intel&#39;}, &#39;intel&#39;: {&#39;diff&#39;, &#39;intel&#39;}}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Details of the algorithm can be found in &#39;Probabilistic Graphical Model</span>
<span class="sd">        Principles and Techniques&#39; - Koller and Friedman</span>
<span class="sd">        Page 75 Algorithm 3.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                <span class="n">observed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>

            <span class="n">observed_list</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">observed</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">observed</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">observed_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ancestors_of</span><span class="p">(</span><span class="n">observed_list</span><span class="p">)</span>

        <span class="c1"># Direction of flow of information</span>
        <span class="c1"># up -&gt;  from parent to child</span>
        <span class="c1"># down -&gt; from child to parent</span>

        <span class="n">active_trails</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]:</span>
            <span class="n">visit_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">traversed_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">active_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">visit_list</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">visit_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traversed_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                        <span class="n">active_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">traversed_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">include_latents</span><span class="p">:</span>
                <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="k">return</span> <span class="n">active_trails</span></div>

    <span class="k">def</span> <span class="nf">_get_ancestors_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of all ancestors of all the observed nodes including the</span>
<span class="sd">        node itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes: string, list-type</span>
<span class="sd">            name of all the observed nodes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; model = DAG([(&#39;D&#39;, &#39;G&#39;), (&#39;I&#39;, &#39;G&#39;), (&#39;G&#39;, &#39;L&#39;),</span>
<span class="sd">        ...                        (&#39;I&#39;, &#39;L&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model._get_ancestors_of(&#39;G&#39;)</span>
<span class="sd">        {&#39;D&#39;, &#39;G&#39;, &#39;I&#39;}</span>
<span class="sd">        &gt;&gt;&gt; model._get_ancestors_of([&#39;G&#39;, &#39;I&#39;])</span>
<span class="sd">        {&#39;D&#39;, &#39;G&#39;, &#39;I&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> not in not in graph&quot;</span><span class="p">)</span>

        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodes_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">nodes_list</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                <span class="n">nodes_list</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="n">ancestors_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ancestors_list</span>

<div class="viewcode-block" id="DAG.to_pdag"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.to_pdag">[docs]</a>    <span class="k">def</span> <span class="nf">to_pdag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the PDAG (the equivalence class of DAG; also known as CPDAG) of the DAG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Partially oriented DAG: pgmpy.base.PDAG</span>
<span class="sd">            An instance of pgmpy.base.PDAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="DAG.do"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.do">[docs]</a>    <span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the do operator to the graph and returns a new DAG with the</span>
<span class="sd">        transformed graph.</span>

<span class="sd">        The do-operator, do(X = x) has the effect of removing all edges from</span>
<span class="sd">        the parents of X and setting X to the given value x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : list, array-like</span>
<span class="sd">            The names of the nodes to apply the do-operator for.</span>

<span class="sd">        inplace: boolean (default: False)</span>
<span class="sd">            If inplace=True, makes the changes to the current object,</span>
<span class="sd">            otherwise returns a new instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Modified DAG: pgmpy.base.DAG</span>
<span class="sd">            A new instance of DAG modified by the do-operator</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialize a DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG()</span>
<span class="sd">        &gt;&gt;&gt; graph.add_edges_from([(&#39;X&#39;, &#39;A&#39;),</span>
<span class="sd">        ...                       (&#39;A&#39;, &#39;Y&#39;),</span>
<span class="sd">        ...                       (&#39;A&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; # Applying the do-operator will return a new DAG with the desired structure.</span>
<span class="sd">        &gt;&gt;&gt; graph_do_A = graph.do(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Which we can verify is missing the edges we would expect.</span>
<span class="sd">        &gt;&gt;&gt; graph_do_A.edges</span>
<span class="sd">        OutEdgeView([(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;Y&#39;)])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Causality: Models, Reasoning, and Inference, Judea Pearl (2000). p.70.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Nodes not found in the model: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                <span class="n">dag</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span></div>

<div class="viewcode-block" id="DAG.get_ancestral_graph"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_ancestral_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_ancestral_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ancestral graph of the given `nodes`. The ancestral graph only</span>
<span class="sd">        contains the nodes which are ancestors of atleast one of the variables in</span>
<span class="sd">        node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: iterable</span>
<span class="sd">            List of nodes whose ancestral graph needs to be computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ancestral Graph: pgmpy.base.DAG</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; anc_dag = dag.get_ancestral_graph(nodes=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; anc_dag.edges()</span>
<span class="sd">        OutEdgeView([(&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ancestors_of</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.to_daft"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.to_daft">[docs]</a>    <span class="k">def</span> <span class="nf">to_daft</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span>
        <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pgm_params</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">edge_params</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">node_params</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a daft (https://docs.daft-pgm.org/en/latest/) object which can be rendered for</span>
<span class="sd">        publication quality plots. The returned object&#39;s render method can be called to see the plots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_pos: str or dict (default: circular)</span>
<span class="sd">            If str: Must be one of the following: circular, kamada_kawai, planar, random, shell, sprint,</span>
<span class="sd">                spectral, spiral. Please refer: https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout for details on these layouts.</span>

<span class="sd">            If dict should be of the form {node: (x coordinate, y coordinate)} describing the x and y coordinate of each</span>
<span class="sd">            node.</span>

<span class="sd">            If no argument is provided uses circular layout.</span>

<span class="sd">        latex: boolean</span>
<span class="sd">            Whether to use latex for rendering the node names.</span>

<span class="sd">        pgm_params: dict (optional)</span>
<span class="sd">            Any additional parameters that need to be passed to `daft.PGM` initializer.</span>
<span class="sd">            Should be of the form: {param_name: param_value}</span>

<span class="sd">        edge_params: dict (optional)</span>
<span class="sd">            Any additional edge parameters that need to be passed to `daft.add_edge` method.</span>
<span class="sd">            Should be of the form: {(u1, v1): {param_name: param_value}, (u2, v2): {...} }</span>

<span class="sd">        node_params: dict (optional)</span>
<span class="sd">            Any additional node parameters that need to be passed to `daft.add_node` method.</span>
<span class="sd">            Should be of the form: {node1: {param_name: param_value}, node2: {...} }</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Daft object: daft.PGM object</span>
<span class="sd">            Daft object for plotting the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;c&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos={&#39;a&#39;: (0, 0), &#39;b&#39;: (1, 0), &#39;c&#39;: (2, 0), &#39;d&#39;: (1, 1)})</span>
<span class="sd">        &lt;daft.PGM at 0x7fc756e936d0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;)</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48c5eb0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;, pgm_params={&#39;observed_style&#39;: &#39;inner&#39;})</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;,</span>
<span class="sd">        ...             edge_params={(&#39;a&#39;, &#39;b&#39;): {&#39;label&#39;: 2}},</span>
<span class="sd">        ...             node_params={&#39;a&#39;: {&#39;shape&#39;: &#39;rectangle&#39;}})</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">daft</span> <span class="kn">import</span> <span class="n">PGM</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;Package daft required. Please visit: https://docs.daft-pgm.org/en/latest/ for installation instructions.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_pos</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">supported_layouts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;circular&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">,</span>
                <span class="s2">&quot;kamada_kawai&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">kamada_kawai_layout</span><span class="p">,</span>
                <span class="s2">&quot;planar&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">planar_layout</span><span class="p">,</span>
                <span class="s2">&quot;random&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">random_layout</span><span class="p">,</span>
                <span class="s2">&quot;shell&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">shell_layout</span><span class="p">,</span>
                <span class="s2">&quot;spring&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">,</span>
                <span class="s2">&quot;spectral&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">,</span>
                <span class="s2">&quot;spiral&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spiral_layout</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">node_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_layouts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown node_pos argument. Please refer docstring for accepted values&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_pos</span> <span class="o">=</span> <span class="n">supported_layouts</span><span class="p">[</span><span class="n">node_pos</span><span class="p">](</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_pos</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_pos</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No position specified for </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Argument node_pos not valid. Please refer to the docstring.&quot;</span>
            <span class="p">)</span>

        <span class="n">daft_pgm</span> <span class="o">=</span> <span class="n">PGM</span><span class="p">(</span><span class="o">**</span><span class="n">pgm_params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="n">node_params</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
                <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="sa">fr</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">,</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="n">edge_params</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">daft_pgm</span></div>

<div class="viewcode-block" id="DAG.get_random"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.get_random">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_random</span><span class="p">(</span><span class="n">n_nodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">edge_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a randomly generated DAG with `n_nodes` number of nodes with</span>
<span class="sd">        edge probability being `edge_prob`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_nodes: int</span>
<span class="sd">            The number of nodes in the randomly generated DAG.</span>

<span class="sd">        edge_prob: float</span>
<span class="sd">            The probability of edge between any two nodes in the topologically</span>
<span class="sd">            sorted DAG.</span>

<span class="sd">        latents: bool (default: False)</span>
<span class="sd">            If True, includes latent variables in the generated DAG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Random DAG: pgmpy.base.DAG</span>
<span class="sd">            The randomly generated DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; random_dag = DAG.get_random(n_nodes=10, edge_prob=0.3)</span>
<span class="sd">        &gt;&gt;&gt; random_dag.nodes()</span>
<span class="sd">        NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))</span>
<span class="sd">        &gt;&gt;&gt; random_dag.edges()</span>
<span class="sd">        OutEdgeView([(0, 6), (1, 6), (1, 7), (7, 9), (2, 5), (2, 7), (2, 8), (5, 9), (3, 7)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Generate a matrix of 0 and 1. Prob of choosing 1 = edge_prob</span>
        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">edge_prob</span><span class="p">,</span> <span class="n">edge_prob</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Step 2: Use the upper triangular part of the matrix as adjacency.</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">convert_matrix</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span>
        <span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>

        <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">latents</span><span class="p">:</span>
            <span class="n">dag</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span></div></div>


<div class="viewcode-block" id="PDAG"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.PDAG">[docs]</a><span class="k">class</span> <span class="nc">PDAG</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for representing PDAGs (also known as CPDAG). PDAGs are the equivance classes of</span>
<span class="sd">    DAGs and contain both directed and undirected edges.</span>

<span class="sd">    Note: In this class, undirected edges are represented using two edges in both direction i.e.</span>
<span class="sd">    an undirected edge between X - Y is represented using X -&gt; Y and X &lt;- Y.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed_ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">undirected_ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a PDAG class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed_ebunch: list, array-like of 2-tuples</span>
<span class="sd">            List of directed edges in the PDAG.</span>

<span class="sd">        undirected_ebunch: list, array-like of 2-tuples</span>
<span class="sd">            List of undirected edges in the PDAG.</span>

<span class="sd">        latents: list, array-like</span>
<span class="sd">            List of nodes which are latent variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        An instance of the PDAG object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PDAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">directed_ebunch</span>
            <span class="o">+</span> <span class="n">undirected_ebunch</span>
            <span class="o">+</span> <span class="p">[(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">undirected_ebunch</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">directed_ebunch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">undirected_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">undirected_ebunch</span><span class="p">)</span>
        <span class="c1"># TODO: Fix the cycle issue</span>
        <span class="c1"># import pdb; pdb.set_trace()</span>
        <span class="c1"># try:</span>
        <span class="c1">#     # Filter out undirected edges as they also form a cycle in</span>
        <span class="c1">#     # themself when represented using directed edges.</span>
        <span class="c1">#     cycles = filter(lambda t: len(t) &gt; 2, nx.simple_cycles(self))</span>
        <span class="c1">#     if cycles:</span>
        <span class="c1">#         out_str = &quot;Cycles are not allowed in a PDAG. &quot;</span>
        <span class="c1">#         out_str += &quot;The following path forms a loop: &quot;</span>
        <span class="c1">#         out_str += &quot;&quot;.join([&quot;({u},{v}) &quot;.format(u=u, v=v) for (u, v) in cycles])</span>
        <span class="c1">#         raise ValueError(out_str)</span>
        <span class="c1"># except nx.NetworkXNoCycle:</span>
        <span class="c1">#     pass</span>

<div class="viewcode-block" id="PDAG.copy"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.PDAG.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the object instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Copy of PDAG: pgmpy.dag.PDAG</span>
<span class="sd">            Returns a copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PDAG</span><span class="p">(</span>
            <span class="n">directed_ebunch</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span>
            <span class="n">undirected_ebunch</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">undirected_edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span>
            <span class="n">latents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PDAG.to_dag"><a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.PDAG.to_dag">[docs]</a>    <span class="k">def</span> <span class="nf">to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_edges</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns one possible DAG which is represented using the PDAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        required_edges: list, array-like of 2-tuples</span>
<span class="sd">            The list of edges that should be included in the DAG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns an instance of DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add required edges if it doesn&#39;t form a new v-structure or an opposite edge</span>
        <span class="c1"># is already present in the network.</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
        <span class="c1"># Add all the nodes and the directed edges</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span><span class="p">)</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="n">pdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">pdag</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># find node with (1) no directed outgoing edges and</span>
            <span class="c1">#                (2) the set of undirecte neighbors is either empty or</span>
            <span class="c1">#                    undirected neighbors + parents of X are a clique</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">directed_outgoing_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdag</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">undirected_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdag</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">neighbors_are_clique</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">pdag</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">undirected_neighbors</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">Z</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">directed_outgoing_edges</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">undirected_neighbors</span> <span class="ow">or</span> <span class="n">neighbors_are_clique</span>
                <span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># add all edges of X as outgoing edges to dag</span>
                    <span class="k">for</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                        <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;PDAG has no faithful extension (= no oriented DAG with the &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;same v-structures as PDAG). Remaining undirected PDAG edges &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;oriented arbitrarily.&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dag</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">dag</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Ankur Ankan.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-177825880-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>
<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pgmpy.base.DAG &#8212; pgmpy 0.1.23 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=7b53859b" />
    <script src="../../../_static/documentation_options.js?v=20522496"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pgmpy.base.DAG</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pgmpy.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="kn">from</span> <span class="nn">pgmpy.global_vars</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">pgmpy.independencies</span> <span class="kn">import</span> <span class="n">Independencies</span>


<div class="viewcode-block" id="DAG">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG">[docs]</a>
<span class="k">class</span> <span class="nc">DAG</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all Directed Graphical Models.</span>

<span class="sd">    Each node in the graph can represent either a random variable, `Factor`,</span>
<span class="sd">    or a cluster of random variables. Edges in the graph represent the</span>
<span class="sd">    dependencies between these.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: input graph</span>
<span class="sd">        Data to initialize graph. If data=None (default) an empty graph is</span>
<span class="sd">        created. The data can be an edge list or any Networkx graph object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an empty DAG with no nodes and no edges</span>

<span class="sd">    &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">    &gt;&gt;&gt; G = DAG()</span>

<span class="sd">    G can be grown in several ways:</span>

<span class="sd">    **Nodes:**</span>

<span class="sd">    Add one node at a time:</span>

<span class="sd">    &gt;&gt;&gt; G.add_node(node=&#39;a&#39;)</span>

<span class="sd">    Add the nodes from any container (a list, set or tuple or the nodes</span>
<span class="sd">    from another graph).</span>

<span class="sd">    &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;a&#39;, &#39;b&#39;])</span>

<span class="sd">    **Edges:**</span>

<span class="sd">    G can also be grown by adding edges.</span>

<span class="sd">    Add one edge,</span>

<span class="sd">    &gt;&gt;&gt; G.add_edge(u=&#39;a&#39;, v=&#39;b&#39;)</span>

<span class="sd">    a list of edges,</span>

<span class="sd">    &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)])</span>

<span class="sd">    If some edges connect nodes not yet in the model, the nodes</span>
<span class="sd">    are added automatically. There are no errors when adding</span>
<span class="sd">    nodes or edges that already exist.</span>

<span class="sd">    **Shortcuts:**</span>

<span class="sd">    Many common graph features allow python syntax for speed reporting.</span>

<span class="sd">    &gt;&gt;&gt; &#39;a&#39; in G     # check if node in graph</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; len(G)  # number of nodes in graph</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXNoCycle</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;Cycles are not allowed in a DAG.&quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges indicating the path taken for a loop: &quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">) &quot;</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.add_node">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.add_node">[docs]</a>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single node to the Graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: str, int, or any hashable python object.</span>
<span class="sd">            The node to add to the graph.</span>

<span class="sd">        weight: int, float</span>
<span class="sd">            The weight of the node.</span>

<span class="sd">        latent: boolean (default: False)</span>
<span class="sd">            Specifies whether the variable is latent or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(node=&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted(G.nodes())</span>
<span class="sd">        [&#39;A&#39;]</span>

<span class="sd">        Adding a node with some weight.</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(node=&#39;B&#39;, weight=0.3)</span>

<span class="sd">        The weight of these nodes can be accessed as:</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;B&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;A&#39;]</span>
<span class="sd">        {&#39;weight&#39;: None}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check for networkx 2.0 syntax</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">attrs</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">latent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="DAG.add_nodes_from">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.add_nodes_from">[docs]</a>
    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add multiple nodes to the Graph.</span>

<span class="sd">        **The behviour of adding weights is different than in networkx.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes: iterable container</span>
<span class="sd">            A container of nodes (list, dict, set, or any hashable python</span>
<span class="sd">            object).</span>

<span class="sd">        weights: list, tuple (default=None)</span>
<span class="sd">            A container of weights (int, float). The weight value at index i</span>
<span class="sd">            is associated with the variable at index i.</span>

<span class="sd">        latent: list, tuple (default=False)</span>
<span class="sd">            A container of boolean. The value at index i tells whether the</span>
<span class="sd">            node at index i is latent or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))</span>

<span class="sd">        Adding nodes with weights:</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;D&#39;, &#39;E&#39;], weights=[0.3, 0.6])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;D&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;E&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.6}</span>
<span class="sd">        &gt;&gt;&gt; G.nodes[&#39;A&#39;]</span>
<span class="sd">        {&#39;weight&#39;: None}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latent</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">latent</span> <span class="o">=</span> <span class="p">[</span><span class="n">latent</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of elements in nodes and weights&quot;</span> <span class="s2">&quot;should be equal.&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">latent</span><span class="o">=</span><span class="n">latent</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">latent</span><span class="o">=</span><span class="n">latent</span><span class="p">[</span><span class="n">index</span><span class="p">])</span></div>


<div class="viewcode-block" id="DAG.add_edge">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.add_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge between u and v.</span>

<span class="sd">        The nodes u and v will be automatically added if they are</span>
<span class="sd">        not already in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u, v : nodes</span>
<span class="sd">            Nodes can be any hashable Python object.</span>

<span class="sd">        weight: int, float (default=None)</span>
<span class="sd">            The weight of the edge</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(u=&#39;Alice&#39;, v=&#39;Bob&#39;)</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>

<span class="sd">        When the node is not already present in the graph:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(u=&#39;Alice&#39;, v=&#39;Ankur&#39;)</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Ankur&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>

<span class="sd">        Adding edges with weight:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edge(&#39;Ankur&#39;, &#39;Maria&#39;, weight=0.1)</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Ankur&#39;][&#39;Maria&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="DAG.add_edges_from">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.add_edges_from">[docs]</a>
    <span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all the edges in ebunch.</span>

<span class="sd">        If nodes referred in the ebunch are not already present, they</span>
<span class="sd">        will be automatically added. Node names can be any hashable python</span>
<span class="sd">        object.</span>

<span class="sd">        **The behavior of adding weights is different than networkx.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebunch : container of edges</span>
<span class="sd">            Each edge given in the container will be added to the graph.</span>
<span class="sd">            The edges must be given as 2-tuples (u, v).</span>

<span class="sd">        weights: list, tuple (default=None)</span>
<span class="sd">            A container of weights (int, float). The weight value at index i</span>
<span class="sd">            is associated with the edge at index i.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_nodes_from(nodes=[&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;])</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>

<span class="sd">        When the node is not already in the model:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from(ebunch=[(&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.nodes()</span>
<span class="sd">        NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;, &#39;Ankur&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.edges()</span>
<span class="sd">        OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>

<span class="sd">        Adding edges with weights:</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;Ankur&#39;, &#39;Maria&#39;), (&#39;Maria&#39;, &#39;Mason&#39;)],</span>
<span class="sd">        ...                  weights=[0.3, 0.5])</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Ankur&#39;][&#39;Maria&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; G.edge[&#39;Maria&#39;][&#39;Mason&#39;]</span>
<span class="sd">        {&#39;weight&#39;: 0.5}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ebunch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of elements in ebunch and weights&quot;</span> <span class="s2">&quot;should be equal&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ebunch</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ebunch</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">ebunch</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="DAG.get_parents">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_parents">[docs]</a>
    <span class="k">def</span> <span class="nf">get_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of parents of node.</span>

<span class="sd">        Throws an error if the node is not present in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">            The node whose parents would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG(ebunch=[(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.get_parents(node=&#39;grade&#39;)</span>
<span class="sd">        [&#39;diff&#39;, &#39;intel&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>


<div class="viewcode-block" id="DAG.moralize">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.moralize">[docs]</a>
    <span class="k">def</span> <span class="nf">moralize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all the immoralities in the DAG and creates a moral</span>
<span class="sd">        graph (UndirectedGraph).</span>

<span class="sd">        A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge</span>
<span class="sd">        between X and Y.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG(ebunch=[(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; moral_graph = G.moralize()</span>
<span class="sd">        &gt;&gt;&gt; moral_graph.edges()</span>
<span class="sd">        EdgeView([(&#39;intel&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;diff&#39;), (&#39;grade&#39;, &#39;diff&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moral_graph</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
        <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">moral_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">moral_graph</span></div>


<div class="viewcode-block" id="DAG.get_leaves">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_leaves">[docs]</a>
    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of leaves of the graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; graph.get_leaves()</span>
<span class="sd">        [&#39;C&#39;, &#39;D&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">out_degree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_degree_iter</span><span class="p">()</span> <span class="k">if</span> <span class="n">out_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="DAG.out_degree_iter">
<a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.out_degree_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">out_degree_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>


<div class="viewcode-block" id="DAG.in_degree_iter">
<a class="viewcode-back" href="../../../base.html#pgmpy.base.DAG.DAG.in_degree_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">in_degree_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">nbunch</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>


<div class="viewcode-block" id="DAG.get_roots">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_roots">[docs]</a>
    <span class="k">def</span> <span class="nf">get_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of roots of the graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;E&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; graph.get_roots()</span>
<span class="sd">        [&#39;A&#39;, &#39;E&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">())</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="DAG.get_children">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_children">[docs]</a>
    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of children of node.</span>
<span class="sd">        Throws an error if the node is not present in the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">            The node whose children would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; g = DAG(ebunch=[(&#39;A&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;D&#39;),</span>
<span class="sd">                                      (&#39;B&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;G&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; g.get_children(node=&#39;B&#39;)</span>
<span class="sd">        [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>


<div class="viewcode-block" id="DAG.get_independencies">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_independencies">[docs]</a>
    <span class="k">def</span> <span class="nf">get_independencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes independencies in the DAG, by checking minimal d-seperation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latex: boolean</span>
<span class="sd">            If latex=True then latex string of the independence assertion</span>
<span class="sd">            would be created.</span>

<span class="sd">        include_latents: boolean</span>
<span class="sd">            If True, includes latent variables in the independencies. Otherwise,</span>
<span class="sd">            only generates independencies on observed variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; chain = DAG([(&#39;X&#39;, &#39;Y&#39;), (&#39;Y&#39;, &#39;Z&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; chain.get_independencies()</span>
<span class="sd">        (X \u27c2 Z | Y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_latents</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="n">independencies</span> <span class="o">=</span> <span class="n">Independencies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">minimal_separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal_dseparator</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="n">include_latents</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">minimal_separator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">independencies</span><span class="o">.</span><span class="n">add_assertions</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">minimal_separator</span><span class="p">])</span>

        <span class="n">independencies</span> <span class="o">=</span> <span class="n">independencies</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">latex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">independencies</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">independencies</span><span class="o">.</span><span class="n">latex_string</span><span class="p">()</span></div>


<div class="viewcode-block" id="DAG.local_independencies">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.local_independencies">[docs]</a>
    <span class="k">def</span> <span class="nf">local_independencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of Independencies containing the local independencies</span>
<span class="sd">        of each of the variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            variables whose local independencies are to be found.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                         (&#39;grade&#39;, &#39;letter&#39;), (&#39;intel&#39;, &#39;SAT&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; ind = student.local_independencies(&#39;grade&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ind</span>
<span class="sd">        (grade \u27c2 SAT | diff, intel)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">independencies</span> <span class="o">=</span> <span class="n">Independencies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">non_descendents</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
                <span class="o">-</span> <span class="p">{</span><span class="n">variable</span><span class="p">}</span>
                <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">non_descendents</span> <span class="o">-</span> <span class="n">parents</span><span class="p">:</span>
                <span class="n">independencies</span><span class="o">.</span><span class="n">add_assertions</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">non_descendents</span> <span class="o">-</span> <span class="n">parents</span><span class="p">,</span> <span class="n">parents</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">independencies</span></div>


<div class="viewcode-block" id="DAG.is_iequivalent">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.is_iequivalent">[docs]</a>
    <span class="k">def</span> <span class="nf">is_iequivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the given model is I-equivalent</span>

<span class="sd">        Two graphs G1 and G2 are said to be I-equivalent if they have same skeleton</span>
<span class="sd">        and have same set of immoralities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : A DAG object, for which you want to check I-equivalence</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        I-equivalence: boolean</span>
<span class="sd">            True if both are I-equivalent, False otherwise</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; G = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;V&#39;, &#39;W&#39;), (&#39;W&#39;, &#39;X&#39;),</span>
<span class="sd">        ...                   (&#39;X&#39;, &#39;Y&#39;), (&#39;Z&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G1 = DAG()</span>
<span class="sd">        &gt;&gt;&gt; G1.add_edges_from([(&#39;W&#39;, &#39;V&#39;), (&#39;X&#39;, &#39;W&#39;),</span>
<span class="sd">        ...                    (&#39;X&#39;, &#39;Y&#39;), (&#39;Z&#39;, &#39;Y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.is_iequivalent(G1)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Model must be an instance of DAG. Got type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span> <span class="o">==</span> <span class="n">model</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DAG.get_immoralities">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_immoralities">[docs]</a>
    <span class="k">def</span> <span class="nf">get_immoralities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the immoralities in the model</span>
<span class="sd">        A v-structure X -&gt; Z &lt;- Y is an immorality if there is no direct edge between X and Y .</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Immoralities: set</span>
<span class="sd">            A set of all the immoralities in the model</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;grade&#39;),</span>
<span class="sd">        ...                         (&#39;intel&#39;, &#39;SAT&#39;), (&#39;grade&#39;, &#39;letter&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.get_immoralities()</span>
<span class="sd">        {(&#39;diff&#39;, &#39;intel&#39;)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">immoralities</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">parent_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">parents</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span>
                    <span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">parent_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">parents</span><span class="p">)))</span>
            <span class="n">immoralities</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_pairs</span>
        <span class="k">return</span> <span class="n">immoralities</span></div>


<div class="viewcode-block" id="DAG.is_dconnected">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.is_dconnected">[docs]</a>
    <span class="k">def</span> <span class="nf">is_dconnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if there is an active trail (i.e. d-connection) between</span>
<span class="sd">        `start` and `end` node given that `observed` is observed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, end : int, str, any hashable python object.</span>
<span class="sd">            The nodes in the DAG between which to check the d-connection/active trail.</span>

<span class="sd">        observed : list, array-like (optional)</span>
<span class="sd">            If given the active trail would be computed assuming these nodes to</span>
<span class="sd">            be observed.</span>

<span class="sd">        include_latents: boolean (default: False)</span>
<span class="sd">            If true, latent variables are return as part of the active trail.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_nodes_from([&#39;diff&#39;, &#39;intel&#39;, &#39;grades&#39;, &#39;letter&#39;, &#39;sat&#39;])</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grades&#39;), (&#39;intel&#39;, &#39;grades&#39;), (&#39;grades&#39;, &#39;letter&#39;),</span>
<span class="sd">        ...                         (&#39;intel&#39;, &#39;sat&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.is_dconnected(&#39;diff&#39;, &#39;intel&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; student.is_dconnected(&#39;grades&#39;, &#39;sat&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">end</span>
            <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span>
                <span class="n">variables</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="n">include_latents</span>
            <span class="p">)[</span><span class="n">start</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DAG.minimal_dseparator">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.minimal_dseparator">[docs]</a>
    <span class="k">def</span> <span class="nf">minimal_dseparator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the minimal d-separating set for `start` and `end`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: node</span>
<span class="sd">            The first node.</span>

<span class="sd">        end: node</span>
<span class="sd">            The second node.</span>

<span class="sd">        include_latents: boolean (default: False)</span>
<span class="sd">            If true, latent variables are consider for minimal d-seperator.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; dag.minimal_dseparator(start=&#39;A&#39;, end=&#39;C&#39;)</span>
<span class="sd">        {&#39;B&#39;}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] Algorithm 4, Page 10: Tian, Jin, Azaria Paz, and Judea Pearl. Finding minimal d-separators. Computer Science Department, University of California, 1998.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">end</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No possible separators because start and end are adjacent&quot;</span>
            <span class="p">)</span>
        <span class="n">an_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ancestral_graph</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_latents</span><span class="p">:</span>
            <span class="c1"># If any of the parents were latents, take the latent&#39;s parent</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">separator</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">separator_copy</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">separator</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">:</span>
                        <span class="n">separator_copy</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                        <span class="n">separator_copy</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
                <span class="n">separator</span> <span class="o">=</span> <span class="n">separator_copy</span>

        <span class="c1"># Remove the start and end nodes in case it reaches there while removing latents.</span>
        <span class="n">separator</span><span class="o">.</span><span class="n">difference_update</span><span class="p">({</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">})</span>

        <span class="c1"># If the initial set is not able to d-separate, no d-separator is possible.</span>
        <span class="k">if</span> <span class="n">an_graph</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">separator</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Go through the separator set, remove one element and check if it remains</span>
        <span class="c1"># a dseparating set.</span>
        <span class="n">minimal_separator</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">separator</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">an_graph</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">minimal_separator</span> <span class="o">-</span> <span class="p">{</span><span class="n">u</span><span class="p">}):</span>
                <span class="n">minimal_separator</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">minimal_separator</span></div>


<div class="viewcode-block" id="DAG.get_markov_blanket">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_markov_blanket">[docs]</a>
    <span class="k">def</span> <span class="nf">get_markov_blanket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a markov blanket for a random variable. In the case</span>
<span class="sd">        of Bayesian Networks, the markov blanket is the set of</span>
<span class="sd">        node&#39;s parents, its children and its children&#39;s other parents.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Markov Blanket: list</span>
<span class="sd">            List of nodes in the markov blanket of `node`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: string, int or any hashable python object.</span>
<span class="sd">              The node whose markov blanket would be returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.factors.discrete import TabularCPD</span>
<span class="sd">        &gt;&gt;&gt; G = DAG([(&#39;x&#39;, &#39;y&#39;), (&#39;z&#39;, &#39;y&#39;), (&#39;y&#39;, &#39;w&#39;), (&#39;y&#39;, &#39;v&#39;), (&#39;u&#39;, &#39;w&#39;),</span>
<span class="sd">                               (&#39;s&#39;, &#39;v&#39;), (&#39;w&#39;, &#39;t&#39;), (&#39;w&#39;, &#39;m&#39;), (&#39;v&#39;, &#39;n&#39;), (&#39;v&#39;, &#39;q&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G.get_markov_blanket(&#39;y&#39;)</span>
<span class="sd">        [&#39;s&#39;, &#39;w&#39;, &#39;x&#39;, &#39;u&#39;, &#39;z&#39;, &#39;v&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">blanket_nodes</span> <span class="o">=</span> <span class="n">children</span> <span class="o">+</span> <span class="n">parents</span>
        <span class="k">for</span> <span class="n">child_node</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">blanket_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">child_node</span><span class="p">))</span>
        <span class="n">blanket_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">blanket_nodes</span><span class="p">)</span>
        <span class="n">blanket_nodes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">blanket_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="DAG.active_trail_nodes">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.active_trail_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">active_trail_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_latents</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the given variables as keys and all the nodes reachable</span>
<span class="sd">        from that respective variable as values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variables: str or array like</span>
<span class="sd">            variables whose active trails are to be found.</span>

<span class="sd">        observed : List of nodes (optional)</span>
<span class="sd">            If given the active trails would be computed assuming these nodes to be</span>
<span class="sd">            observed.</span>

<span class="sd">        include_latents: boolean (default: False)</span>
<span class="sd">            Whether to include the latent variables in the returned active trail nodes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; student = DAG()</span>
<span class="sd">        &gt;&gt;&gt; student.add_nodes_from([&#39;diff&#39;, &#39;intel&#39;, &#39;grades&#39;])</span>
<span class="sd">        &gt;&gt;&gt; student.add_edges_from([(&#39;diff&#39;, &#39;grades&#39;), (&#39;intel&#39;, &#39;grades&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; student.active_trail_nodes(&#39;diff&#39;)</span>
<span class="sd">        {&#39;diff&#39;: {&#39;diff&#39;, &#39;grades&#39;}}</span>
<span class="sd">        &gt;&gt;&gt; student.active_trail_nodes([&#39;diff&#39;, &#39;intel&#39;], observed=&#39;grades&#39;)</span>
<span class="sd">        {&#39;diff&#39;: {&#39;diff&#39;, &#39;intel&#39;}, &#39;intel&#39;: {&#39;diff&#39;, &#39;intel&#39;}}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Details of the algorithm can be found in &#39;Probabilistic Graphical Model</span>
<span class="sd">        Principles and Techniques&#39; - Koller and Friedman</span>
<span class="sd">        Page 75 Algorithm 3.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                <span class="n">observed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span>

            <span class="n">observed_list</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">observed</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">observed</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">observed_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ancestors_of</span><span class="p">(</span><span class="n">observed_list</span><span class="p">)</span>

        <span class="c1"># Direction of flow of information</span>
        <span class="c1"># up -&gt;  from parent to child</span>
        <span class="c1"># down -&gt; from child to parent</span>

        <span class="n">active_trails</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">variables</span><span class="p">]:</span>
            <span class="n">visit_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="n">traversed_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">active_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">visit_list</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">visit_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traversed_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                        <span class="n">active_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">traversed_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                            <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">observed_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                                <span class="n">visit_list</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">include_latents</span><span class="p">:</span>
                <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">active_trails</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_nodes</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="k">return</span> <span class="n">active_trails</span></div>


    <span class="k">def</span> <span class="nf">_get_ancestors_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of all ancestors of all the observed nodes including the</span>
<span class="sd">        node itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes: string, list-type</span>
<span class="sd">            name of all the observed nodes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; model = DAG([(&#39;D&#39;, &#39;G&#39;), (&#39;I&#39;, &#39;G&#39;), (&#39;G&#39;, &#39;L&#39;),</span>
<span class="sd">        ...                        (&#39;I&#39;, &#39;L&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; model._get_ancestors_of(&#39;G&#39;)</span>
<span class="sd">        {&#39;D&#39;, &#39;G&#39;, &#39;I&#39;}</span>
<span class="sd">        &gt;&gt;&gt; model._get_ancestors_of([&#39;G&#39;, &#39;I&#39;])</span>
<span class="sd">        {&#39;D&#39;, &#39;G&#39;, &#39;I&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> not in graph&quot;</span><span class="p">)</span>

        <span class="n">ancestors_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodes_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">nodes_list</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors_list</span><span class="p">:</span>
                <span class="n">nodes_list</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="n">ancestors_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ancestors_list</span>

    <span class="c1"># TODO: Commented out till the method is implemented.</span>
    <span class="c1">#     def to_pdag(self):</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         Returns the PDAG (the equivalence class of DAG; also known as CPDAG) of the DAG.</span>
    <span class="c1">#</span>
    <span class="c1">#         Returns</span>
    <span class="c1">#         -------</span>
    <span class="c1">#         Partially oriented DAG: pgmpy.base.PDAG</span>
    <span class="c1">#             An instance of pgmpy.base.PDAG.</span>
    <span class="c1">#</span>
    <span class="c1">#         Examples</span>
    <span class="c1">#         --------</span>
    <span class="c1">#</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         pass</span>

<div class="viewcode-block" id="DAG.do">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.do">[docs]</a>
    <span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the do operator to the graph and returns a new DAG with the</span>
<span class="sd">        transformed graph.</span>

<span class="sd">        The do-operator, do(X = x) has the effect of removing all edges from</span>
<span class="sd">        the parents of X and setting X to the given value x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : list, array-like</span>
<span class="sd">            The names of the nodes to apply the do-operator for.</span>

<span class="sd">        inplace: boolean (default: False)</span>
<span class="sd">            If inplace=True, makes the changes to the current object,</span>
<span class="sd">            otherwise returns a new instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Modified DAG: pgmpy.base.DAG</span>
<span class="sd">            A new instance of DAG modified by the do-operator</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialize a DAG</span>
<span class="sd">        &gt;&gt;&gt; graph = DAG()</span>
<span class="sd">        &gt;&gt;&gt; graph.add_edges_from([(&#39;X&#39;, &#39;A&#39;),</span>
<span class="sd">        ...                       (&#39;A&#39;, &#39;Y&#39;),</span>
<span class="sd">        ...                       (&#39;A&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; # Applying the do-operator will return a new DAG with the desired structure.</span>
<span class="sd">        &gt;&gt;&gt; graph_do_A = graph.do(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Which we can verify is missing the edges we would expect.</span>
<span class="sd">        &gt;&gt;&gt; graph_do_A.edges</span>
<span class="sd">        OutEdgeView([(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;Y&#39;)])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Causality: Models, Reasoning, and Inference, Judea Pearl (2000). p.70.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Nodes not found in the model: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                <span class="n">dag</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span></div>


<div class="viewcode-block" id="DAG.get_ancestral_graph">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_ancestral_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ancestral_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ancestral graph of the given `nodes`. The ancestral graph only</span>
<span class="sd">        contains the nodes which are ancestors of atleast one of the variables in</span>
<span class="sd">        node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: iterable</span>
<span class="sd">            List of nodes whose ancestral graph needs to be computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ancestral Graph: pgmpy.base.DAG</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; anc_dag = dag.get_ancestral_graph(nodes=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; anc_dag.edges()</span>
<span class="sd">        OutEdgeView([(&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ancestors_of</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">))</span></div>


<div class="viewcode-block" id="DAG.to_daft">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.to_daft">[docs]</a>
    <span class="k">def</span> <span class="nf">to_daft</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span>
        <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pgm_params</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">edge_params</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">node_params</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a daft (https://docs.daft-pgm.org/en/latest/) object which can be rendered for</span>
<span class="sd">        publication quality plots. The returned object&#39;s render method can be called to see the plots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_pos: str or dict (default: circular)</span>
<span class="sd">            If str: Must be one of the following: circular, kamada_kawai, planar, random, shell, sprint,</span>
<span class="sd">                spectral, spiral. Please refer: https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout for details on these layouts.</span>

<span class="sd">            If dict should be of the form {node: (x coordinate, y coordinate)} describing the x and y coordinate of each</span>
<span class="sd">            node.</span>

<span class="sd">            If no argument is provided uses circular layout.</span>

<span class="sd">        latex: boolean</span>
<span class="sd">            Whether to use latex for rendering the node names.</span>

<span class="sd">        pgm_params: dict (optional)</span>
<span class="sd">            Any additional parameters that need to be passed to `daft.PGM` initializer.</span>
<span class="sd">            Should be of the form: {param_name: param_value}</span>

<span class="sd">        edge_params: dict (optional)</span>
<span class="sd">            Any additional edge parameters that need to be passed to `daft.add_edge` method.</span>
<span class="sd">            Should be of the form: {(u1, v1): {param_name: param_value}, (u2, v2): {...} }</span>

<span class="sd">        node_params: dict (optional)</span>
<span class="sd">            Any additional node parameters that need to be passed to `daft.add_node` method.</span>
<span class="sd">            Should be of the form: {node1: {param_name: param_value}, node2: {...} }</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Daft object: daft.PGM object</span>
<span class="sd">            Daft object for plotting the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;c&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos={&#39;a&#39;: (0, 0), &#39;b&#39;: (1, 0), &#39;c&#39;: (2, 0), &#39;d&#39;: (1, 1)})</span>
<span class="sd">        &lt;daft.PGM at 0x7fc756e936d0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;)</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48c5eb0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;, pgm_params={&#39;observed_style&#39;: &#39;inner&#39;})</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag.to_daft(node_pos=&quot;circular&quot;,</span>
<span class="sd">        ...             edge_params={(&#39;a&#39;, &#39;b&#39;): {&#39;label&#39;: 2}},</span>
<span class="sd">        ...             node_params={&#39;a&#39;: {&#39;shape&#39;: &#39;rectangle&#39;}})</span>
<span class="sd">        &lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">daft</span> <span class="kn">import</span> <span class="n">PGM</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">msg</span>
                <span class="o">+</span> <span class="s2">&quot;. Package daft required. Please visit: https://docs.daft-pgm.org/en/latest/ for installation instructions.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_pos</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">supported_layouts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;circular&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">,</span>
                <span class="s2">&quot;kamada_kawai&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">kamada_kawai_layout</span><span class="p">,</span>
                <span class="s2">&quot;planar&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">planar_layout</span><span class="p">,</span>
                <span class="s2">&quot;random&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">random_layout</span><span class="p">,</span>
                <span class="s2">&quot;shell&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">shell_layout</span><span class="p">,</span>
                <span class="s2">&quot;spring&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">,</span>
                <span class="s2">&quot;spectral&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">,</span>
                <span class="s2">&quot;spiral&quot;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">spiral_layout</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">node_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_layouts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown node_pos argument. Please refer docstring for accepted values&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_pos</span> <span class="o">=</span> <span class="n">supported_layouts</span><span class="p">[</span><span class="n">node_pos</span><span class="p">](</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_pos</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_pos</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No position specified for </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Argument node_pos not valid. Please refer to the docstring.&quot;</span>
            <span class="p">)</span>

        <span class="n">daft_pgm</span> <span class="o">=</span> <span class="n">PGM</span><span class="p">(</span><span class="o">**</span><span class="n">pgm_params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="n">node_params</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
                <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="sa">rf</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">,</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">node_pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="n">edge_params</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">extra_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">daft_pgm</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">daft_pgm</span></div>


<div class="viewcode-block" id="DAG.get_random">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.get_random">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_random</span><span class="p">(</span><span class="n">n_nodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">edge_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a randomly generated DAG with `n_nodes` number of nodes with</span>
<span class="sd">        edge probability being `edge_prob`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_nodes: int</span>
<span class="sd">            The number of nodes in the randomly generated DAG.</span>

<span class="sd">        edge_prob: float</span>
<span class="sd">            The probability of edge between any two nodes in the topologically</span>
<span class="sd">            sorted DAG.</span>

<span class="sd">        node_names: list (default: None)</span>
<span class="sd">            A list of variables names to use in the random graph.</span>
<span class="sd">            If None, the node names are integer values starting from 0.</span>

<span class="sd">        latents: bool (default: False)</span>
<span class="sd">            If True, includes latent variables in the generated DAG.</span>

<span class="sd">        seed: int (default: None)</span>
<span class="sd">            The seed for the random number generator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Random DAG: pgmpy.base.DAG</span>
<span class="sd">            The randomly generated DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; random_dag = DAG.get_random(n_nodes=10, edge_prob=0.3)</span>
<span class="sd">        &gt;&gt;&gt; random_dag.nodes()</span>
<span class="sd">        NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))</span>
<span class="sd">        &gt;&gt;&gt; random_dag.edges()</span>
<span class="sd">        OutEdgeView([(0, 6), (1, 6), (1, 7), (7, 9), (2, 5), (2, 7), (2, 8), (5, 9), (3, 7)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Generate a matrix of 0 and 1. Prob of choosing 1 = edge_prob</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">edge_prob</span><span class="p">,</span> <span class="n">edge_prob</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Step 2: Use the upper triangular part of the matrix as adjacency.</span>
        <span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">))</span>

        <span class="n">adj_pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">node_names</span>
        <span class="p">)</span>
        <span class="n">nx_dag</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_adjacency</span><span class="p">(</span><span class="n">adj_pd</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span>

        <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">nx_dag</span><span class="p">)</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">latents</span><span class="p">:</span>
            <span class="n">dag</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">gen</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="n">gen</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">())))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span></div>


<div class="viewcode-block" id="DAG.to_graphviz">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.to_graphviz">[docs]</a>
    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retuns a pygraphviz object for the DAG. pygraphviz is useful for</span>
<span class="sd">        visualizing the network structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.utils import get_example_model</span>
<span class="sd">        &gt;&gt;&gt; model = get_example_model(&#39;alarm&#39;)</span>
<span class="sd">        &gt;&gt;&gt; model.to_graphviz()</span>
<span class="sd">        &lt;AGraph &lt;Swig Object of type &#39;Agraph_t *&#39; at 0x7fdea4cde040&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; model.draw(&#39;model.png&#39;, prog=&#39;neato&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="DAG.fit">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.DAG.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the CPD for each variable based on a given data set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: pandas DataFrame object</span>
<span class="sd">            DataFrame object with column names identical to the variable names of the network.</span>
<span class="sd">            (If some values in the data are missing the data cells should be set to `numpy.nan`.</span>
<span class="sd">            Note that pandas converts each column containing `numpy.nan`s to dtype `float`.)</span>

<span class="sd">        estimator: Estimator class</span>
<span class="sd">            One of:</span>
<span class="sd">            - MaximumLikelihoodEstimator (default)</span>
<span class="sd">            - BayesianEstimator: In this case, pass &#39;prior_type&#39; and either &#39;pseudo_counts&#39;</span>
<span class="sd">            or &#39;equivalent_sample_size&#39; as additional keyword arguments.</span>
<span class="sd">            See `BayesianEstimator.get_parameters()` for usage.</span>
<span class="sd">            - ExpectationMaximization</span>

<span class="sd">        state_names: dict (optional)</span>
<span class="sd">            A dict indicating, for each variable, the discrete set of states</span>
<span class="sd">            that the variable can take. If unspecified, the observed values</span>
<span class="sd">            in the data set are taken to be the only possible states.</span>

<span class="sd">        n_jobs: int (default: 1)</span>
<span class="sd">            Number of threads/processes to use for estimation. Using n_jobs &gt; 1</span>
<span class="sd">            for small models or datasets might be slower.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Fitted Model: BayesianNetwork</span>
<span class="sd">            Returns a BayesianNetwork object with learned CPDs.</span>
<span class="sd">            The DAG structure is preserved, and parameters (CPDs) are added.</span>
<span class="sd">            This allows the DAG to represent both the structure and the parameters of a Bayesian Network.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.models import BayesianNetwork</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.base import DAG</span>
<span class="sd">        &gt;&gt;&gt; data = pd.DataFrame(data={&#39;A&#39;: [0, 0, 1], &#39;B&#39;: [0, 1, 0], &#39;C&#39;: [1, 1, 0]})</span>
<span class="sd">        &gt;&gt;&gt; model = DAG([(&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; fitted_model = model.fit(data)</span>
<span class="sd">        &gt;&gt;&gt; fitted_model.get_cpds()</span>
<span class="sd">        [&lt;TabularCPD representing P(A:2) at 0x17945372c30&gt;,</span>
<span class="sd">        &lt;TabularCPD representing P(B:2) at 0x17945a19760&gt;,</span>
<span class="sd">        &lt;TabularCPD representing P(C:2 | A:2, B:2) at 0x17944f42690&gt;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pgmpy.estimators</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">MaximumLikelihoodEstimator</span>
        <span class="kn">from</span> <span class="nn">pgmpy.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BayesianNetwork</span><span class="p">):</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">estimator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">estimator</span> <span class="o">=</span> <span class="n">MaximumLikelihoodEstimator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Estimator object should be a valid pgmpy estimator.&quot;</span><span class="p">)</span>

        <span class="n">_estimator</span> <span class="o">=</span> <span class="n">estimator</span><span class="p">(</span>
            <span class="n">bn</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">state_names</span><span class="o">=</span><span class="n">state_names</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cpds_list</span> <span class="o">=</span> <span class="n">_estimator</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">bn</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="o">*</span><span class="n">cpds_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bn</span></div>
</div>



<div class="viewcode-block" id="PDAG">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.PDAG">[docs]</a>
<span class="k">class</span> <span class="nc">PDAG</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for representing PDAGs (also known as CPDAG). PDAGs are the equivalence classes of</span>
<span class="sd">    DAGs and contain both directed and undirected edges.</span>

<span class="sd">    Note: In this class, undirected edges are represented using two edges in both direction i.e.</span>
<span class="sd">    an undirected edge between X - Y is represented using X -&gt; Y and X &lt;- Y.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed_ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">undirected_ebunch</span><span class="o">=</span><span class="p">[],</span> <span class="n">latents</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a PDAG class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed_ebunch: list, array-like of 2-tuples</span>
<span class="sd">            List of directed edges in the PDAG.</span>

<span class="sd">        undirected_ebunch: list, array-like of 2-tuples</span>
<span class="sd">            List of undirected edges in the PDAG.</span>

<span class="sd">        latents: list, array-like</span>
<span class="sd">            List of nodes which are latent variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        An instance of the PDAG object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PDAG</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">directed_ebunch</span>
            <span class="o">+</span> <span class="n">undirected_ebunch</span>
            <span class="o">+</span> <span class="p">[(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">undirected_ebunch</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">latents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">directed_ebunch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">undirected_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">undirected_ebunch</span><span class="p">)</span>
        <span class="c1"># TODO: Fix the cycle issue</span>
        <span class="c1"># import pdb; pdb.set_trace()</span>
        <span class="c1"># try:</span>
        <span class="c1">#     # Filter out undirected edges as they also form a cycle in</span>
        <span class="c1">#     # themself when represented using directed edges.</span>
        <span class="c1">#     cycles = filter(lambda t: len(t) &gt; 2, nx.simple_cycles(self))</span>
        <span class="c1">#     if cycles:</span>
        <span class="c1">#         out_str = &quot;Cycles are not allowed in a PDAG. &quot;</span>
        <span class="c1">#         out_str += &quot;The following path forms a loop: &quot;</span>
        <span class="c1">#         out_str += &quot;&quot;.join([&quot;({u},{v}) &quot;.format(u=u, v=v) for (u, v) in cycles])</span>
        <span class="c1">#         raise ValueError(out_str)</span>
        <span class="c1"># except nx.NetworkXNoCycle:</span>
        <span class="c1">#     pass</span>

<div class="viewcode-block" id="PDAG.copy">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.PDAG.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the object instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Copy of PDAG: pgmpy.dag.PDAG</span>
<span class="sd">            Returns a copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PDAG</span><span class="p">(</span>
            <span class="n">directed_ebunch</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span>
            <span class="n">undirected_ebunch</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">undirected_edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span>
            <span class="n">latents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">latents</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PDAG.to_dag">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.PDAG.to_dag">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns one possible DAG which is represented using the PDAG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns an instance of DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] Dor, Dorit, and Michael Tarsi. &quot;A simple algorithm to construct a consistent extension of a partially oriented graph.&quot; Technicial Report R-185, Cognitive Systems Laboratory, UCLA (1992): 45.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add required edges if it doesn&#39;t form a new v-structure or an opposite edge</span>
        <span class="c1"># is already present in the network.</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
        <span class="c1"># Add all the nodes and the directed edges</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directed_edges</span><span class="p">)</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">latents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latents</span>

        <span class="n">pdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">pdag</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># find node with (1) no directed outgoing edges and</span>
            <span class="c1">#                (2) the set of undirected neighbors is either empty or</span>
            <span class="c1">#                    undirected neighbors + parents of X are a clique</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">directed_outgoing_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdag</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">undirected_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdag</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">neighbors_are_clique</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">pdag</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">undirected_neighbors</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">Z</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">directed_outgoing_edges</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">undirected_neighbors</span> <span class="ow">or</span> <span class="n">neighbors_are_clique</span>
                <span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># add all edges of X as outgoing edges to dag</span>
                    <span class="k">for</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                        <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                    <span class="n">pdag</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;PDAG has no faithful extension (= no oriented DAG with the &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;same v-structures as PDAG). Remaining undirected PDAG edges &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;oriented arbitrarily.&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">pdag</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dag</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">dag</span></div>


<div class="viewcode-block" id="PDAG.to_graphviz">
<a class="viewcode-back" href="../../../base/base.html#pgmpy.base.DAG.PDAG.to_graphviz">[docs]</a>
    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retuns a pygraphviz object for the DAG. pygraphviz is useful for</span>
<span class="sd">        visualizing the network structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pgmpy.utils import get_example_model</span>
<span class="sd">        &gt;&gt;&gt; model = get_example_model(&#39;alarm&#39;)</span>
<span class="sd">        &gt;&gt;&gt; model.to_graphviz()</span>
<span class="sd">        &lt;AGraph &lt;Swig Object of type &#39;Agraph_t *&#39; at 0x7fdea4cde040&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">nx_agraph</span><span class="o">.</span><span class="n">to_agraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../started/base.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base/base.html">Base Model Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/base.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../factors/base.html">Parameterization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/base.html">Exact Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exact_infer/model_testing.html">Model Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../approx_infer/base.html">Approximate Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../param_estimator/base.html">Parameter Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_estimator/base.html">Structure Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metrics/metrics.html">Metrics for testing models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readwrite/base.html">Reading/Writing to File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plotting.html">Plotting Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial Notebooks</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>







<script async src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>

<div data-ea-publisher="pgmpyorg" data-ea-type="image" data-ea-style="horizontal"></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-HCFR07M31W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HCFR07M31W');
</script>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2023, Ankur Ankan.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>